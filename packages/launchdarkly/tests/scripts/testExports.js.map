{
  "version": 3,
  "sources": ["../../../../node_modules/.pnpm/superstruct@0.16.5/node_modules/superstruct/src/error.ts", "../../../../node_modules/.pnpm/superstruct@0.16.5/node_modules/superstruct/src/utils.ts", "../../../../node_modules/.pnpm/superstruct@0.16.5/node_modules/superstruct/src/struct.ts", "../../../../node_modules/.pnpm/superstruct@0.16.5/node_modules/superstruct/src/structs/utilities.ts", "../../../../node_modules/.pnpm/superstruct@0.16.5/node_modules/superstruct/src/structs/types.ts", "../../../../node_modules/.pnpm/superstruct@0.16.5/node_modules/superstruct/src/structs/coercions.ts", "../../../../node_modules/.pnpm/superstruct@0.16.5/node_modules/superstruct/src/structs/refinements.ts", "../../../../global/constants/attributes.ts", "../../../../node_modules/.pnpm/@finsweet+ts-utils@0.35.0/node_modules/@finsweet/ts-utils/dist/type-guards/isKeyOf.js", "../../../../node_modules/.pnpm/@finsweet+ts-utils@0.35.0/node_modules/@finsweet/ts-utils/dist/helpers/extractCommaSeparatedValues.js", "../../../../global/factory/selectors.ts", "../../src/utils/constants.ts", "../../src/actions/loaders.ts", "../../src/utils/type-guards.ts", "../../src/actions/properties.ts", "../../src/factory.ts", "../../src/testExports.ts"],
  "sourcesContent": ["/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n\nexport type Failure = {\n  value: any\n  key: any\n  type: string\n  refinement: string | undefined\n  message: string\n  branch: Array<any>\n  path: Array<any>\n}\n\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\n\nexport class StructError extends TypeError {\n  value: any\n  key!: any\n  type!: string\n  refinement!: string | undefined\n  path!: Array<any>\n  branch!: Array<any>\n  failures: () => Array<Failure>;\n  [x: string]: any\n\n  constructor(failure: Failure, failures: () => Generator<Failure>) {\n    let cached: Array<Failure> | undefined\n    const { message, ...rest } = failure\n    const { path } = failure\n    const msg =\n      path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`\n    super(msg)\n    Object.assign(this, rest)\n    this.name = this.constructor.name\n    this.failures = () => {\n      return (cached ??= [failure, ...failures()])\n    }\n  }\n}\n", "import { Struct, Infer, Result, Context, Describe } from './struct'\nimport { Failure } from './error'\n\n/**\n * Check if a value is an iterator.\n */\n\nfunction isIterable<T>(x: unknown): x is Iterable<T> {\n  return isObject(x) && typeof x[Symbol.iterator] === 'function'\n}\n\n/**\n * Check if a value is a plain object.\n */\n\nexport function isObject(x: unknown): x is object {\n  return typeof x === 'object' && x != null\n}\n\n/**\n * Check if a value is a plain object.\n */\n\nexport function isPlainObject(x: unknown): x is { [key: string]: any } {\n  if (Object.prototype.toString.call(x) !== '[object Object]') {\n    return false\n  }\n\n  const prototype = Object.getPrototypeOf(x)\n  return prototype === null || prototype === Object.prototype\n}\n\n/**\n * Return a value as a printable string.\n */\n\nexport function print(value: any): string {\n  return typeof value === 'string' ? JSON.stringify(value) : `${value}`\n}\n\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\n\nexport function shiftIterator<T>(input: Iterator<T>): T | undefined {\n  const { done, value } = input.next()\n  return done ? undefined : value\n}\n\n/**\n * Convert a single validation result to a failure.\n */\n\nexport function toFailure<T, S>(\n  result: string | boolean | Partial<Failure>,\n  context: Context,\n  struct: Struct<T, S>,\n  value: any\n): Failure | undefined {\n  if (result === true) {\n    return\n  } else if (result === false) {\n    result = {}\n  } else if (typeof result === 'string') {\n    result = { message: result }\n  }\n\n  const { path, branch } = context\n  const { type } = struct\n  const {\n    refinement,\n    message = `Expected a value of type \\`${type}\\`${\n      refinement ? ` with refinement \\`${refinement}\\`` : ''\n    }, but received: \\`${print(value)}\\``,\n  } = result\n\n  return {\n    value,\n    type,\n    refinement,\n    key: path[path.length - 1],\n    path,\n    branch,\n    ...result,\n    message,\n  }\n}\n\n/**\n * Convert a validation result to an iterable of failures.\n */\n\nexport function* toFailures<T, S>(\n  result: Result,\n  context: Context,\n  struct: Struct<T, S>,\n  value: any\n): IterableIterator<Failure> {\n  if (!isIterable(result)) {\n    result = [result]\n  }\n\n  for (const r of result) {\n    const failure = toFailure(r, context, struct, value)\n\n    if (failure) {\n      yield failure\n    }\n  }\n}\n\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\n\nexport function* run<T, S>(\n  value: unknown,\n  struct: Struct<T, S>,\n  options: {\n    path?: any[]\n    branch?: any[]\n    coerce?: boolean\n    mask?: boolean\n  } = {}\n): IterableIterator<[Failure, undefined] | [undefined, T]> {\n  const { path = [], branch = [value], coerce = false, mask = false } = options\n  const ctx: Context = { path, branch }\n\n  if (coerce) {\n    value = struct.coercer(value, ctx)\n\n    if (\n      mask &&\n      struct.type !== 'type' &&\n      isObject(struct.schema) &&\n      isObject(value) &&\n      !Array.isArray(value)\n    ) {\n      for (const key in value) {\n        if (struct.schema[key] === undefined) {\n          delete value[key]\n        }\n      }\n    }\n  }\n\n  let status: 'valid' | 'not_refined' | 'not_valid' = 'valid'\n\n  for (const failure of struct.validator(value, ctx)) {\n    status = 'not_valid'\n    yield [failure, undefined]\n  }\n\n  for (let [k, v, s] of struct.entries(value, ctx)) {\n    const ts = run(v, s as Struct, {\n      path: k === undefined ? path : [...path, k],\n      branch: k === undefined ? branch : [...branch, v],\n      coerce,\n      mask,\n    })\n\n    for (const t of ts) {\n      if (t[0]) {\n        status = t[0].refinement != null ? 'not_refined' : 'not_valid'\n        yield [t[0], undefined]\n      } else if (coerce) {\n        v = t[1]\n\n        if (k === undefined) {\n          value = v\n        } else if (value instanceof Map) {\n          value.set(k, v)\n        } else if (value instanceof Set) {\n          value.add(v)\n        } else if (isObject(value)) {\n          if (v !== undefined) value[k] = v\n        }\n      }\n    }\n  }\n\n  if (status !== 'not_valid') {\n    for (const failure of struct.refiner(value as T, ctx)) {\n      status = 'not_refined'\n      yield [failure, undefined]\n    }\n  }\n\n  if (status === 'valid') {\n    yield [undefined, value as T]\n  }\n}\n\n/**\n * Convert a union of type to an intersection.\n */\n\nexport type UnionToIntersection<U> = (\n  U extends any ? (arg: U) => any : never\n) extends (arg: infer I) => void\n  ? I\n  : never\n\n/**\n * Assign properties from one type to another, overwriting existing.\n */\n\nexport type Assign<T, U> = Simplify<U & Omit<T, keyof U>>\n\n/**\n * A schema for enum structs.\n */\n\nexport type EnumSchema<T extends string | number | undefined> = {\n  [K in NonNullable<T>]: K\n}\n\n/**\n * Check if a type is a match for another whilst treating overlapping\n * unions as a match.\n */\n\nexport type IsMatch<T, G> = T extends G ? (G extends T ? T : never) : never\n\n/**\n * Check if a type is an exact match.\n */\n\nexport type IsExactMatch<T, U> = (<G>() => G extends T ? 1 : 2) extends <\n  G\n>() => G extends U ? 1 : 2\n  ? T\n  : never\n\n/**\n * Check if a type is a record type.\n */\n\nexport type IsRecord<T> = T extends object\n  ? string extends keyof T\n    ? T\n    : never\n  : never\n/**\n * Check if a type is a tuple.\n */\n\nexport type IsTuple<T> = T extends [any]\n  ? T\n  : T extends [any, any]\n  ? T\n  : T extends [any, any, any]\n  ? T\n  : T extends [any, any, any, any]\n  ? T\n  : T extends [any, any, any, any, any]\n  ? T\n  : never\n\n/**\n * Check if a type is a union.\n */\n\nexport type IsUnion<T, U extends T = T> = (\n  T extends any ? (U extends T ? false : true) : false\n) extends false\n  ? never\n  : T\n\n/**\n * A schema for object structs.\n */\n\nexport type ObjectSchema = Record<string, Struct<any, any>>\n\n/**\n * Infer a type from an object struct schema.\n */\n\nexport type ObjectType<S extends ObjectSchema> = Simplify<\n  Optionalize<{ [K in keyof S]: Infer<S[K]> }>\n>\n\n/**\n * Omit properties from a type that extend from a specific type.\n */\n\nexport type OmitBy<T, V> = Omit<\n  T,\n  { [K in keyof T]: V extends Extract<T[K], V> ? K : never }[keyof T]\n>\n\n/**\n * Normalize properties of a type that allow `undefined` to make them optional.\n */\n\nexport type Optionalize<S extends object> = OmitBy<S, undefined> &\n  Partial<PickBy<S, undefined>>\n\n/**\n * Transform an object schema type to represent a partial.\n */\n\nexport type PartialObjectSchema<S extends ObjectSchema> = {\n  [K in keyof S]: Struct<Infer<S[K]> | undefined>\n}\n\n/**\n * Pick properties from a type that extend from a specific type.\n */\n\nexport type PickBy<T, V> = Pick<\n  T,\n  { [K in keyof T]: V extends Extract<T[K], V> ? K : never }[keyof T]\n>\n\n/**\n * Simplifies a type definition to its most basic representation.\n */\n\nexport type Simplify<T> = T extends any[] | Date\n  ? T\n  : { [K in keyof T]: T[K] } & {}\n\nexport type If<B extends Boolean, Then, Else> = B extends true ? Then : Else\n\n/**\n * A schema for any type of struct.\n */\n\nexport type StructSchema<T> = [T] extends [string | undefined]\n  ? [T] extends [IsMatch<T, string | undefined>]\n    ? null\n    : [T] extends [IsUnion<T>]\n    ? EnumSchema<T>\n    : T\n  : [T] extends [number | undefined]\n  ? [T] extends [IsMatch<T, number | undefined>]\n    ? null\n    : [T] extends [IsUnion<T>]\n    ? EnumSchema<T>\n    : T\n  : [T] extends [boolean]\n  ? [T] extends [IsExactMatch<T, boolean>]\n    ? null\n    : T\n  : T extends\n      | bigint\n      | symbol\n      | undefined\n      | null\n      | Function\n      | Date\n      | Error\n      | RegExp\n      | Map<any, any>\n      | WeakMap<any, any>\n      | Set<any>\n      | WeakSet<any>\n      | Promise<any>\n  ? null\n  : T extends Array<infer E>\n  ? T extends IsTuple<T>\n    ? null\n    : Struct<E>\n  : T extends object\n  ? T extends IsRecord<T>\n    ? null\n    : { [K in keyof T]: Describe<T[K]> }\n  : null\n\n/**\n * A schema for tuple structs.\n */\n\nexport type TupleSchema<T> = { [K in keyof T]: Struct<T[K]> }\n\n/**\n * Shorthand type for matching any `Struct`.\n */\n\nexport type AnyStruct = Struct<any, any>\n\n/**\n * Infer a tuple of types from a tuple of `Struct`s.\n *\n * This is used to recursively retrieve the type from `union` `intersection` and\n * `tuple` structs.\n */\n\nexport type InferStructTuple<\n  Tuple extends AnyStruct[],\n  Length extends number = Tuple['length']\n> = Length extends Length\n  ? number extends Length\n    ? Tuple\n    : _InferTuple<Tuple, Length, []>\n  : never\ntype _InferTuple<\n  Tuple extends AnyStruct[],\n  Length extends number,\n  Accumulated extends unknown[],\n  Index extends number = Accumulated['length']\n> = Index extends Length\n  ? Accumulated\n  : _InferTuple<Tuple, Length, [...Accumulated, Infer<Tuple[Index]>]>\n", "import { toFailures, shiftIterator, StructSchema, run } from './utils'\nimport { StructError, Failure } from './error'\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\n\nexport class Struct<T = unknown, S = unknown> {\n  readonly TYPE!: T\n  type: string\n  schema: S\n  coercer: (value: unknown, context: Context) => unknown\n  validator: (value: unknown, context: Context) => Iterable<Failure>\n  refiner: (value: T, context: Context) => Iterable<Failure>\n  entries: (\n    value: unknown,\n    context: Context\n  ) => Iterable<[string | number, unknown, Struct<any> | Struct<never>]>\n\n  constructor(props: {\n    type: string\n    schema: S\n    coercer?: Coercer\n    validator?: Validator\n    refiner?: Refiner<T>\n    entries?: Struct<T, S>['entries']\n  }) {\n    const {\n      type,\n      schema,\n      validator,\n      refiner,\n      coercer = (value: unknown) => value,\n      entries = function* () {},\n    } = props\n\n    this.type = type\n    this.schema = schema\n    this.entries = entries\n    this.coercer = coercer\n\n    if (validator) {\n      this.validator = (value, context) => {\n        const result = validator(value, context)\n        return toFailures(result, context, this, value)\n      }\n    } else {\n      this.validator = () => []\n    }\n\n    if (refiner) {\n      this.refiner = (value, context) => {\n        const result = refiner(value, context)\n        return toFailures(result, context, this, value)\n      }\n    } else {\n      this.refiner = () => []\n    }\n  }\n\n  /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */\n\n  assert(value: unknown): asserts value is T {\n    return assert(value, this)\n  }\n\n  /**\n   * Create a value with the struct's coercion logic, then validate it.\n   */\n\n  create(value: unknown): T {\n    return create(value, this)\n  }\n\n  /**\n   * Check if a value passes the struct's validation.\n   */\n\n  is(value: unknown): value is T {\n    return is(value, this)\n  }\n\n  /**\n   * Mask a value, coercing and validating it, but returning only the subset of\n   * properties defined by the struct's schema.\n   */\n\n  mask(value: unknown): T {\n    return mask(value, this)\n  }\n\n  /**\n   * Validate a value with the struct's validation logic, returning a tuple\n   * representing the result.\n   *\n   * You may optionally pass `true` for the `withCoercion` argument to coerce\n   * the value before attempting to validate it. If you do, the result will\n   * contain the coerced result when successful.\n   */\n\n  validate(\n    value: unknown,\n    options: {\n      coerce?: boolean\n    } = {}\n  ): [StructError, undefined] | [undefined, T] {\n    return validate(value, this, options)\n  }\n}\n\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\n\nexport function assert<T, S>(\n  value: unknown,\n  struct: Struct<T, S>\n): asserts value is T {\n  const result = validate(value, struct)\n\n  if (result[0]) {\n    throw result[0]\n  }\n}\n\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\n\nexport function create<T, S>(value: unknown, struct: Struct<T, S>): T {\n  const result = validate(value, struct, { coerce: true })\n\n  if (result[0]) {\n    throw result[0]\n  } else {\n    return result[1]\n  }\n}\n\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\n\nexport function mask<T, S>(value: unknown, struct: Struct<T, S>): T {\n  const result = validate(value, struct, { coerce: true, mask: true })\n\n  if (result[0]) {\n    throw result[0]\n  } else {\n    return result[1]\n  }\n}\n\n/**\n * Check if a value passes a struct.\n */\n\nexport function is<T, S>(value: unknown, struct: Struct<T, S>): value is T {\n  const result = validate(value, struct)\n  return !result[0]\n}\n\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\n\nexport function validate<T, S>(\n  value: unknown,\n  struct: Struct<T, S>,\n  options: {\n    coerce?: boolean\n    mask?: boolean\n  } = {}\n): [StructError, undefined] | [undefined, T] {\n  const tuples = run(value, struct, options)\n  const tuple = shiftIterator(tuples)!\n\n  if (tuple[0]) {\n    const error = new StructError(tuple[0], function* () {\n      for (const t of tuples) {\n        if (t[0]) {\n          yield t[0]\n        }\n      }\n    })\n\n    return [error, undefined]\n  } else {\n    const v = tuple[1]\n    return [undefined, v]\n  }\n}\n\n/**\n * A `Context` contains information about the current location of the\n * validation inside the initial input value.\n */\n\nexport type Context = {\n  branch: Array<any>\n  path: Array<any>\n}\n\n/**\n * A type utility to extract the type from a `Struct` class.\n */\n\nexport type Infer<T extends Struct<any, any>> = T['TYPE']\n\n/**\n * A type utility to describe that a struct represents a TypeScript type.\n */\n\nexport type Describe<T> = Struct<T, StructSchema<T>>\n\n/**\n * A `Result` is returned from validation functions.\n */\n\nexport type Result =\n  | boolean\n  | string\n  | Partial<Failure>\n  | Iterable<boolean | string | Partial<Failure>>\n\n/**\n * A `Coercer` takes an unknown value and optionally coerces it.\n */\n\nexport type Coercer<T = unknown> = (value: T, context: Context) => unknown\n\n/**\n * A `Validator` takes an unknown value and validates it.\n */\n\nexport type Validator = (value: unknown, context: Context) => Result\n\n/**\n * A `Refiner` takes a value of a known type and validates it against a further\n * constraint.\n */\n\nexport type Refiner<T> = (value: T, context: Context) => Result\n", "import { Struct, Context, Validator } from '../struct'\nimport { object, optional, type } from './types'\nimport { ObjectSchema, Assign, ObjectType, PartialObjectSchema } from '../utils'\n\n/**\n * Create a new struct that combines the properties properties from multiple\n * object or type structs. Its return type will match the first parameter's type.\n *\n * Like JavaScript's `Object.assign` utility.\n */\n\nexport function assign<A extends ObjectSchema, B extends ObjectSchema>(\n  A: Struct<ObjectType<A>, A>,\n  B: Struct<ObjectType<B>, B>\n): Struct<ObjectType<Assign<A, B>>, Assign<A, B>>\nexport function assign<\n  A extends ObjectSchema,\n  B extends ObjectSchema,\n  C extends ObjectSchema\n>(\n  A: Struct<ObjectType<A>, A>,\n  B: Struct<ObjectType<B>, B>,\n  C: Struct<ObjectType<C>, C>\n): Struct<ObjectType<Assign<Assign<A, B>, C>>, Assign<Assign<A, B>, C>>\nexport function assign<\n  A extends ObjectSchema,\n  B extends ObjectSchema,\n  C extends ObjectSchema,\n  D extends ObjectSchema\n>(\n  A: Struct<ObjectType<A>, A>,\n  B: Struct<ObjectType<B>, B>,\n  C: Struct<ObjectType<C>, C>,\n  D: Struct<ObjectType<D>, D>\n): Struct<\n  ObjectType<Assign<Assign<Assign<A, B>, C>, D>>,\n  Assign<Assign<Assign<A, B>, C>, D>\n>\nexport function assign<\n  A extends ObjectSchema,\n  B extends ObjectSchema,\n  C extends ObjectSchema,\n  D extends ObjectSchema,\n  E extends ObjectSchema\n>(\n  A: Struct<ObjectType<A>, A>,\n  B: Struct<ObjectType<B>, B>,\n  C: Struct<ObjectType<C>, C>,\n  D: Struct<ObjectType<D>, D>,\n  E: Struct<ObjectType<E>, E>\n): Struct<\n  ObjectType<Assign<Assign<Assign<Assign<A, B>, C>, D>, E>>,\n  Assign<Assign<Assign<Assign<A, B>, C>, D>, E>\n>\nexport function assign(...Structs: Struct<any>[]): any {\n  const isType = Structs[0].type === 'type'\n  const schemas = Structs.map((s) => s.schema)\n  const schema = Object.assign({}, ...schemas)\n  return isType ? type(schema) : object(schema)\n}\n\n/**\n * Define a new struct type with a custom validation function.\n */\n\nexport function define<T>(name: string, validator: Validator): Struct<T, null> {\n  return new Struct({ type: name, schema: null, validator })\n}\n\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\n\nexport function deprecated<T>(\n  struct: Struct<T>,\n  log: (value: unknown, ctx: Context) => void\n): Struct<T> {\n  return new Struct({\n    ...struct,\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n    validator(value, ctx) {\n      if (value === undefined) {\n        return true\n      } else {\n        log(value, ctx)\n        return struct.validator(value, ctx)\n      }\n    },\n  })\n}\n\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\n\nexport function dynamic<T>(\n  fn: (value: unknown, ctx: Context) => Struct<T, any>\n): Struct<T, null> {\n  return new Struct({\n    type: 'dynamic',\n    schema: null,\n    *entries(value, ctx) {\n      const struct = fn(value, ctx)\n      yield* struct.entries(value, ctx)\n    },\n    validator(value, ctx) {\n      const struct = fn(value, ctx)\n      return struct.validator(value, ctx)\n    },\n    coercer(value, ctx) {\n      const struct = fn(value, ctx)\n      return struct.coercer(value, ctx)\n    },\n    refiner(value, ctx) {\n      const struct = fn(value, ctx)\n      return struct.refiner(value, ctx)\n    },\n  })\n}\n\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\n\nexport function lazy<T>(fn: () => Struct<T, any>): Struct<T, null> {\n  let struct: Struct<T, any> | undefined\n  return new Struct({\n    type: 'lazy',\n    schema: null,\n    *entries(value, ctx) {\n      struct ??= fn()\n      yield* struct.entries(value, ctx)\n    },\n    validator(value, ctx) {\n      struct ??= fn()\n      return struct.validator(value, ctx)\n    },\n    coercer(value, ctx) {\n      struct ??= fn()\n      return struct.coercer(value, ctx)\n    },\n    refiner(value, ctx) {\n      struct ??= fn()\n      return struct.refiner(value, ctx)\n    },\n  })\n}\n\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\n\nexport function omit<S extends ObjectSchema, K extends keyof S>(\n  struct: Struct<ObjectType<S>, S>,\n  keys: K[]\n): Struct<ObjectType<Omit<S, K>>, Omit<S, K>> {\n  const { schema } = struct\n  const subschema: any = { ...schema }\n\n  for (const key of keys) {\n    delete subschema[key]\n  }\n\n  switch (struct.type) {\n    case 'type':\n      return type(subschema as Omit<S, K>)\n    default:\n      return object(subschema as Omit<S, K>)\n  }\n}\n\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\n\nexport function partial<S extends ObjectSchema>(\n  struct: Struct<ObjectType<S>, S> | S\n): Struct<ObjectType<PartialObjectSchema<S>>, PartialObjectSchema<S>> {\n  const schema: any =\n    struct instanceof Struct ? { ...struct.schema } : { ...struct }\n\n  for (const key in schema) {\n    schema[key] = optional(schema[key])\n  }\n\n  return object(schema) as any\n}\n\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\n\nexport function pick<S extends ObjectSchema, K extends keyof S>(\n  struct: Struct<ObjectType<S>, S>,\n  keys: K[]\n): Struct<ObjectType<Pick<S, K>>, Pick<S, K>> {\n  const { schema } = struct\n  const subschema: any = {}\n\n  for (const key of keys) {\n    subschema[key] = schema[key]\n  }\n\n  return object(subschema as Pick<S, K>)\n}\n\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\n\nexport function struct<T>(name: string, validator: Validator): Struct<T, null> {\n  console.warn(\n    'superstruct@0.11 - The `struct` helper has been renamed to `define`.'\n  )\n\n  return define(name, validator)\n}\n", "import { Infer, Struct } from '../struct'\nimport { define } from './utilities'\nimport {\n  ObjectSchema,\n  ObjectType,\n  print,\n  run,\n  isObject,\n  AnyStruct,\n  InferStructTuple,\n  UnionToIntersection,\n} from '../utils'\n\n/**\n * Ensure that any value passes validation.\n */\n\nexport function any(): Struct<any, null> {\n  return define('any', () => true)\n}\n\n/**\n * Ensure that a value is an array and that its elements are of a specific type.\n *\n * Note: If you omit the element struct, the arrays elements will not be\n * iterated at all. This can be helpful for cases where performance is critical,\n * and it is preferred to using `array(any())`.\n */\n\nexport function array<T extends Struct<any>>(Element: T): Struct<Infer<T>[], T>\nexport function array(): Struct<unknown[], undefined>\nexport function array<T extends Struct<any>>(Element?: T): any {\n  return new Struct({\n    type: 'array',\n    schema: Element,\n    *entries(value) {\n      if (Element && Array.isArray(value)) {\n        for (const [i, v] of value.entries()) {\n          yield [i, v, Element]\n        }\n      }\n    },\n    coercer(value) {\n      return Array.isArray(value) ? value.slice() : value\n    },\n    validator(value) {\n      return (\n        Array.isArray(value) ||\n        `Expected an array value, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a bigint.\n */\n\nexport function bigint(): Struct<bigint, null> {\n  return define('bigint', (value) => {\n    return typeof value === 'bigint'\n  })\n}\n\n/**\n * Ensure that a value is a boolean.\n */\n\nexport function boolean(): Struct<boolean, null> {\n  return define('boolean', (value) => {\n    return typeof value === 'boolean'\n  })\n}\n\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\n\nexport function date(): Struct<Date, null> {\n  return define('date', (value) => {\n    return (\n      (value instanceof Date && !isNaN(value.getTime())) ||\n      `Expected a valid \\`Date\\` object, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is one of a set of potential values.\n *\n * Note: after creating the struct, you can access the definition of the\n * potential values as `struct.schema`.\n */\n\nexport function enums<U extends number, T extends readonly U[]>(\n  values: T\n): Struct<T[number], { [K in T[number]]: K }>\nexport function enums<U extends string, T extends readonly U[]>(\n  values: T\n): Struct<T[number], { [K in T[number]]: K }>\nexport function enums<U extends string | number, T extends readonly U[]>(\n  values: T\n): any {\n  const schema: any = {}\n  const description = values.map((v) => print(v)).join()\n\n  for (const key of values) {\n    schema[key] = key\n  }\n\n  return new Struct({\n    type: 'enums',\n    schema,\n    validator(value) {\n      return (\n        values.includes(value as any) ||\n        `Expected one of \\`${description}\\`, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a function.\n */\n\nexport function func(): Struct<Function, null> {\n  return define('func', (value) => {\n    return (\n      typeof value === 'function' ||\n      `Expected a function, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is an instance of a specific class.\n */\n\nexport function instance<T extends { new (...args: any): any }>(\n  Class: T\n): Struct<InstanceType<T>, null> {\n  return define('instance', (value) => {\n    return (\n      value instanceof Class ||\n      `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is an integer.\n */\n\nexport function integer(): Struct<number, null> {\n  return define('integer', (value) => {\n    return (\n      (typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n      `Expected an integer, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value matches all of a set of types.\n */\n\nexport function intersection<A extends AnyStruct, B extends AnyStruct[]>(\n  Structs: [A, ...B]\n): Struct<Infer<A> & UnionToIntersection<InferStructTuple<B>[number]>, null> {\n  return new Struct({\n    type: 'intersection',\n    schema: null,\n    *entries(value, ctx) {\n      for (const S of Structs) {\n        yield* S.entries(value, ctx)\n      }\n    },\n    *validator(value, ctx) {\n      for (const S of Structs) {\n        yield* S.validator(value, ctx)\n      }\n    },\n    *refiner(value, ctx) {\n      for (const S of Structs) {\n        yield* S.refiner(value, ctx)\n      }\n    },\n  })\n}\n\n/**\n * Ensure that a value is an exact value, using `===` for comparison.\n */\n\nexport function literal<T extends boolean>(constant: T): Struct<T, T>\nexport function literal<T extends number>(constant: T): Struct<T, T>\nexport function literal<T extends string>(constant: T): Struct<T, T>\nexport function literal<T>(constant: T): Struct<T, null>\nexport function literal<T>(constant: T): any {\n  const description = print(constant)\n  const t = typeof constant\n  return new Struct({\n    type: 'literal',\n    schema:\n      t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n    validator(value) {\n      return (\n        value === constant ||\n        `Expected the literal \\`${description}\\`, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a `Map` object, and that its keys and values are of\n * specific types.\n */\n\nexport function map(): Struct<Map<unknown, unknown>, null>\nexport function map<K, V>(\n  Key: Struct<K>,\n  Value: Struct<V>\n): Struct<Map<K, V>, null>\nexport function map<K, V>(Key?: Struct<K>, Value?: Struct<V>): any {\n  return new Struct({\n    type: 'map',\n    schema: null,\n    *entries(value) {\n      if (Key && Value && value instanceof Map) {\n        for (const [k, v] of value.entries()) {\n          yield [k as string, k, Key]\n          yield [k as string, v, Value]\n        }\n      }\n    },\n    coercer(value) {\n      return value instanceof Map ? new Map(value) : value\n    },\n    validator(value) {\n      return (\n        value instanceof Map ||\n        `Expected a \\`Map\\` object, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that no value ever passes validation.\n */\n\nexport function never(): Struct<never, null> {\n  return define('never', () => false)\n}\n\n/**\n * Augment an existing struct to allow `null` values.\n */\n\nexport function nullable<T, S>(struct: Struct<T, S>): Struct<T | null, S> {\n  return new Struct({\n    ...struct,\n    validator: (value, ctx) => value === null || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === null || struct.refiner(value, ctx),\n  })\n}\n\n/**\n * Ensure that a value is a number.\n */\n\nexport function number(): Struct<number, null> {\n  return define('number', (value) => {\n    return (\n      (typeof value === 'number' && !isNaN(value)) ||\n      `Expected a number, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is an object, that is has a known set of properties,\n * and that its properties are of specific types.\n *\n * Note: Unrecognized properties will fail validation.\n */\n\nexport function object(): Struct<Record<string, unknown>, null>\nexport function object<S extends ObjectSchema>(\n  schema: S\n): Struct<ObjectType<S>, S>\nexport function object<S extends ObjectSchema>(schema?: S): any {\n  const knowns = schema ? Object.keys(schema) : []\n  const Never = never()\n  return new Struct({\n    type: 'object',\n    schema: schema ? schema : null,\n    *entries(value) {\n      if (schema && isObject(value)) {\n        const unknowns = new Set(Object.keys(value))\n\n        for (const key of knowns) {\n          unknowns.delete(key)\n          yield [key, value[key], schema[key]]\n        }\n\n        for (const key of unknowns) {\n          yield [key, value[key], Never]\n        }\n      }\n    },\n    validator(value) {\n      return (\n        isObject(value) || `Expected an object, but received: ${print(value)}`\n      )\n    },\n    coercer(value) {\n      return isObject(value) ? { ...value } : value\n    },\n  })\n}\n\n/**\n * Augment a struct to allow `undefined` values.\n */\n\nexport function optional<T, S>(struct: Struct<T, S>): Struct<T | undefined, S> {\n  return new Struct({\n    ...struct,\n    validator: (value, ctx) =>\n      value === undefined || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n  })\n}\n\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\n\nexport function record<K extends string, V>(\n  Key: Struct<K>,\n  Value: Struct<V>\n): Struct<Record<K, V>, null> {\n  return new Struct({\n    type: 'record',\n    schema: null,\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k in value) {\n          const v = value[k]\n          yield [k, k, Key]\n          yield [k, v, Value]\n        }\n      }\n    },\n    validator(value) {\n      return (\n        isObject(value) || `Expected an object, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\n\nexport function regexp(): Struct<RegExp, null> {\n  return define('regexp', (value) => {\n    return value instanceof RegExp\n  })\n}\n\n/**\n * Ensure that a value is a `Set` object, and that its elements are of a\n * specific type.\n */\n\nexport function set(): Struct<Set<unknown>, null>\nexport function set<T>(Element: Struct<T>): Struct<Set<T>, null>\nexport function set<T>(Element?: Struct<T>): any {\n  return new Struct({\n    type: 'set',\n    schema: null,\n    *entries(value) {\n      if (Element && value instanceof Set) {\n        for (const v of value) {\n          yield [v as string, v, Element]\n        }\n      }\n    },\n    coercer(value) {\n      return value instanceof Set ? new Set(value) : value\n    },\n    validator(value) {\n      return (\n        value instanceof Set ||\n        `Expected a \\`Set\\` object, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a string.\n */\n\nexport function string(): Struct<string, null> {\n  return define('string', (value) => {\n    return (\n      typeof value === 'string' ||\n      `Expected a string, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */\n\nexport function tuple<A extends AnyStruct, B extends AnyStruct[]>(\n  Structs: [A, ...B]\n): Struct<[Infer<A>, ...InferStructTuple<B>], null> {\n  const Never = never()\n\n  return new Struct({\n    type: 'tuple',\n    schema: null,\n    *entries(value) {\n      if (Array.isArray(value)) {\n        const length = Math.max(Structs.length, value.length)\n\n        for (let i = 0; i < length; i++) {\n          yield [i, value[i], Structs[i] || Never]\n        }\n      }\n    },\n    validator(value) {\n      return (\n        Array.isArray(value) ||\n        `Expected an array, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\n\nexport function type<S extends ObjectSchema>(\n  schema: S\n): Struct<ObjectType<S>, S> {\n  const keys = Object.keys(schema)\n  return new Struct({\n    type: 'type',\n    schema,\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k of keys) {\n          yield [k, value[k], schema[k]]\n        }\n      }\n    },\n    validator(value) {\n      return (\n        isObject(value) || `Expected an object, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value matches one of a set of types.\n */\n\nexport function union<A extends AnyStruct, B extends AnyStruct[]>(\n  Structs: [A, ...B]\n): Struct<Infer<A> | InferStructTuple<B>[number], null> {\n  const description = Structs.map((s) => s.type).join(' | ')\n  return new Struct({\n    type: 'union',\n    schema: null,\n    coercer(value, ctx) {\n      const firstMatch =\n        Structs.find((s) => {\n          const [e] = s.validate(value, { coerce: true })\n          return !e\n        }) || unknown()\n      return firstMatch.coercer(value, ctx)\n    },\n    validator(value, ctx) {\n      const failures = []\n\n      for (const S of Structs) {\n        const [...tuples] = run(value, S, ctx)\n        const [first] = tuples\n\n        if (!first[0]) {\n          return []\n        } else {\n          for (const [failure] of tuples) {\n            if (failure) {\n              failures.push(failure)\n            }\n          }\n        }\n      }\n\n      return [\n        `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(\n          value\n        )}`,\n        ...failures,\n      ]\n    },\n  })\n}\n\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\n\nexport function unknown(): Struct<unknown, null> {\n  return define('unknown', () => true)\n}\n", "import { Struct, is, Coercer } from '../struct'\nimport { isPlainObject } from '../utils'\nimport { string, unknown } from './types'\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation\u2014for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nexport function coerce<T, S, C>(\n  struct: Struct<T, S>,\n  condition: Struct<C, any>,\n  coercer: Coercer<C>\n): Struct<T, S> {\n  return new Struct({\n    ...struct,\n    coercer: (value, ctx) => {\n      return is(value, condition)\n        ? struct.coercer(coercer(value, ctx), ctx)\n        : struct.coercer(value, ctx)\n    },\n  })\n}\n\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nexport function defaulted<T, S>(\n  struct: Struct<T, S>,\n  fallback: any,\n  options: {\n    strict?: boolean\n  } = {}\n): Struct<T, S> {\n  return coerce(struct, unknown(), (x) => {\n    const f = typeof fallback === 'function' ? fallback() : fallback\n\n    if (x === undefined) {\n      return f\n    }\n\n    if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n      const ret = { ...x }\n      let changed = false\n\n      for (const key in f) {\n        if (ret[key] === undefined) {\n          ret[key] = f[key]\n          changed = true\n        }\n      }\n\n      if (changed) {\n        return ret\n      }\n    }\n\n    return x\n  })\n}\n\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nexport function trimmed<T, S>(struct: Struct<T, S>): Struct<T, S> {\n  return coerce(struct, string(), (x) => x.trim())\n}\n", "import { Struct, Refiner } from '../struct'\nimport { toFailures } from '../utils'\n\n/**\n * Ensure that a string, array, map, or set is empty.\n */\n\nexport function empty<\n  T extends string | any[] | Map<any, any> | Set<any>,\n  S extends any\n>(struct: Struct<T, S>): Struct<T, S> {\n  return refine(struct, 'empty', (value) => {\n    const size = getSize(value)\n    return (\n      size === 0 ||\n      `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``\n    )\n  })\n}\n\nfunction getSize(value: string | any[] | Map<any, any> | Set<any>): number {\n  if (value instanceof Map || value instanceof Set) {\n    return value.size\n  } else {\n    return value.length\n  }\n}\n\n/**\n * Ensure that a number or date is below a threshold.\n */\n\nexport function max<T extends number | Date, S extends any>(\n  struct: Struct<T, S>,\n  threshold: T,\n  options: {\n    exclusive?: boolean\n  } = {}\n): Struct<T, S> {\n  const { exclusive } = options\n  return refine(struct, 'max', (value) => {\n    return exclusive\n      ? value < threshold\n      : value <= threshold ||\n          `Expected a ${struct.type} less than ${\n            exclusive ? '' : 'or equal to '\n          }${threshold} but received \\`${value}\\``\n  })\n}\n\n/**\n * Ensure that a number or date is above a threshold.\n */\n\nexport function min<T extends number | Date, S extends any>(\n  struct: Struct<T, S>,\n  threshold: T,\n  options: {\n    exclusive?: boolean\n  } = {}\n): Struct<T, S> {\n  const { exclusive } = options\n  return refine(struct, 'min', (value) => {\n    return exclusive\n      ? value > threshold\n      : value >= threshold ||\n          `Expected a ${struct.type} greater than ${\n            exclusive ? '' : 'or equal to '\n          }${threshold} but received \\`${value}\\``\n  })\n}\n\n/**\n * Ensure that a string, array, map or set is not empty.\n */\n\nexport function nonempty<\n  T extends string | any[] | Map<any, any> | Set<any>,\n  S extends any\n>(struct: Struct<T, S>): Struct<T, S> {\n  return refine(struct, 'nonempty', (value) => {\n    const size = getSize(value)\n    return (\n      size > 0 || `Expected a nonempty ${struct.type} but received an empty one`\n    )\n  })\n}\n\n/**\n * Ensure that a string matches a regular expression.\n */\n\nexport function pattern<T extends string, S extends any>(\n  struct: Struct<T, S>,\n  regexp: RegExp\n): Struct<T, S> {\n  return refine(struct, 'pattern', (value) => {\n    return (\n      regexp.test(value) ||\n      `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`\n    )\n  })\n}\n\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\n\nexport function size<\n  T extends string | number | Date | any[] | Map<any, any> | Set<any>,\n  S extends any\n>(struct: Struct<T, S>, min: number, max: number = min): Struct<T, S> {\n  const expected = `Expected a ${struct.type}`\n  const of = min === max ? `of \\`${min}\\`` : `between \\`${min}\\` and \\`${max}\\``\n\n  return refine(struct, 'size', (value) => {\n    if (typeof value === 'number' || value instanceof Date) {\n      return (\n        (min <= value && value <= max) ||\n        `${expected} ${of} but received \\`${value}\\``\n      )\n    } else if (value instanceof Map || value instanceof Set) {\n      const { size } = value\n      return (\n        (min <= size && size <= max) ||\n        `${expected} with a size ${of} but received one with a size of \\`${size}\\``\n      )\n    } else {\n      const { length } = value as string | any[]\n      return (\n        (min <= length && length <= max) ||\n        `${expected} with a length ${of} but received one with a length of \\`${length}\\``\n      )\n    }\n  })\n}\n\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\n\nexport function refine<T, S>(\n  struct: Struct<T, S>,\n  name: string,\n  refiner: Refiner<T>\n): Struct<T, S> {\n  return new Struct({\n    ...struct,\n    *refiner(value, ctx) {\n      yield* struct.refiner(value, ctx)\n      const result = refiner(value, ctx)\n      const failures = toFailures(result, ctx, struct, value)\n\n      for (const failure of failures) {\n        yield { ...failure, refinement: name }\n      }\n    },\n  })\n}\n", "export const ATTRIBUTES_PREFIX = 'fs-attributes';\r\n\r\nexport const EXAMPLE_ATTRIBUTE = 'example';\r\n\r\nexport const A11Y_ATTRIBUTE = 'a11y';\r\n\r\nexport const ANIMATION_ATTRIBUTE = 'animation';\r\n\r\nexport const AUTO_VIDEO_ATTRIBUTE = 'autovideo';\r\n\r\nexport const CMS_CORE = 'cmscore';\r\n\r\nexport const CMS_ATTRIBUTE_ATTRIBUTE = 'cmsattribute';\r\n\r\nexport const CMS_COMBINE_ATTRIBUTE = 'cmscombine';\r\n\r\nexport const CMS_CSS_ATTRIBUTE = 'cmscss';\r\n\r\nexport const CMS_FILTER_ATTRIBUTE = 'cmsfilter';\r\n\r\nexport const CMS_LOAD_ATTRIBUTE = 'cmsload';\r\n\r\nexport const CMS_NEST_ATTRIBUTE = 'cmsnest';\r\n\r\nexport const CMS_PREV_NEXT_ATTRIBUTE = 'cmsprevnext';\r\n\r\nexport const CMS_STATIC_ATTRIBUTE = 'cmsstatic';\r\n\r\nexport const CMS_SELECT_ATTRIBUTE = 'cmsselect';\r\n\r\nexport const CMS_SLIDER_ATTRIBUTE = 'cmsslider';\r\n\r\nexport const CMS_SORT_ATTRIBUTE = 'cmssort';\r\n\r\nexport const CMS_TABS_ATTRIBUTE = 'cmstabs';\r\n\r\nexport const CODE_HIGHLIGHT_ATTRIBUTE = 'codehighlight';\r\n\r\nexport const COPY_CLIP_ATTRIBUTE = 'copyclip';\r\n\r\nexport const COUNT_ITEMS_ATTRIBUTE = 'countitems';\r\n\r\nexport const DISPLAY_VALUES_ATTRIBUTE = 'displayvalues';\r\n\r\nexport const DOCS_ATTRIBUTE = 'docs';\r\n\r\nexport const FAV_CUSTOM_ATTRIBUTE = 'favcustom';\r\n\r\nexport const FORM_SUBMIT_ATTRIBUTE = 'formsubmit';\r\n\r\nexport const GREENHOUSE_ATTRIBUTE = 'greenhouse';\r\n\r\nexport const LINK_BLOCK_EDIT_ATTRIBUTE = 'linkblockedit';\r\n\r\nexport const MIRROR_CLICK_ATTRIBUTE = 'mirrorclick';\r\n\r\nexport const MIRROR_INPUT_ATTRIBUTE = 'mirrorinput';\r\n\r\nexport const LAUNCHDARKLY_ATTRIBUTE = 'launchdarkly';\r\n\r\nexport const QUERY_PARAM_ATTRIBUTE = 'queryparam';\r\n\r\nexport const RANGE_SLIDER_ATTRIBUTE = 'rangeslider';\r\n\r\nexport const RICH_TEXT_ATTRIBUTE = 'richtext';\r\n\r\nexport const SCROLL_DISABLE_ATTRIBUTE = 'scrolldisable';\r\n\r\nexport const SELECT_CUSTOM_ATTRIBUTE = 'selectcustom';\r\n\r\nexport const SLIDER_DOTS_ATTRIBUTE = 'sliderdots';\r\n\r\nexport const SMART_LIGHTBOX_ATTRIBUTE = 'smartlightbox';\r\n\r\nexport const SOCIAL_SHARE_ATTRIBUTE = 'socialshare';\r\n\r\nexport const TOC_ATTRIBUTE = 'toc';\r\n\r\nexport const READ_TIME_ATTRIBUTE = 'readtime';\r\n", "/**\n * Check if a key is included in a readonly array\n * @param key\n * @param source readonly array of strings\n * @returns True/false\n */\nexport const isKeyOf = (key, source) => !!key && source.includes(key);\n", "import { isKeyOf } from '../type-guards/isKeyOf';\nexport function extractCommaSeparatedValues(string, compareSource, defaultValue, filterEmpty = true) {\n    const emptyValue = defaultValue ? [defaultValue] : [];\n    if (!string)\n        return emptyValue;\n    const items = string.split(',').reduce((accumulatedValue, currentValue) => {\n        const value = currentValue.trim();\n        if (!filterEmpty || value)\n            accumulatedValue.push(value);\n        return accumulatedValue;\n    }, []);\n    if (compareSource) {\n        const matches = items.filter((item) => isKeyOf(item, compareSource));\n        return matches.length ? matches : emptyValue;\n    }\n    return items;\n}\n", "import type { AttributeOperator, AttributeStaticValue, AttributeValue } from './types';\r\n\r\n/**\r\n * Creates a dynamic attribute value.\r\n * @param value The static attribute value.\r\n * @returns A callback for generating new attribute values by index.\r\n */\r\nexport const generateDynamicAttibuteValue = (value: string) => {\r\n  return (index?: number): string => `${value}${index ? `-${index}` : ''}`;\r\n};\r\n\r\n/**\r\n * @returns A `getSelector` callback for the passed `attributes` object.\r\n * @param attributes An object containing all attribute keys and values.\r\n */\r\nexport const generateSelectors = <\r\n  Attributes extends {\r\n    [name: string]: {\r\n      key: string;\r\n      values?: {\r\n        [valueKey: string]: AttributeValue;\r\n      };\r\n    };\r\n  }\r\n>(\r\n  attributes: Attributes\r\n) => {\r\n  type AttributesValues = Attributes['element']['values'];\r\n  type AttributesValuesKeys = keyof AttributesValues;\r\n  type AttributeStaticParams = {\r\n    operator?: AttributeOperator;\r\n    caseInsensitive?: boolean;\r\n  };\r\n  type AttributeDynamicParams = AttributeStaticParams & {\r\n    instanceIndex?: number;\r\n    caseInsensitive?: boolean;\r\n  };\r\n\r\n  /**\r\n   * Generates a query selector based on the preferences.\r\n   * @param name The name of the attribute.\r\n   * @param valueKey The value of the attribute.\r\n   * @param params.index Only accepted when the value is dynamic.\r\n   * @param params.operator Optional operator for the selector.\r\n   * @returns The query selector based on the preferences.\r\n   */\r\n  const getSelector = <Name extends keyof Attributes, ValueKey extends keyof Attributes[Name]['values']>(\r\n    name: Name,\r\n    valueKey?: ValueKey,\r\n    params?: Attributes[Name]['values'][ValueKey] extends AttributeStaticValue\r\n      ? AttributeStaticParams\r\n      : AttributeDynamicParams\r\n  ): string => {\r\n    const attribute = attributes[name];\r\n\r\n    const { key: attributeKey, values } = attribute;\r\n    let attributeValue: string;\r\n\r\n    if (!valueKey) return `[${attributeKey}]`;\r\n\r\n    const value = values?.[valueKey] as AttributeValue;\r\n\r\n    if (typeof value === 'string') attributeValue = value;\r\n    else attributeValue = value(params && 'instanceIndex' in params ? params.instanceIndex : undefined);\r\n\r\n    const caseInsensitive = params && 'caseInsensitive' in params && params.caseInsensitive ? 'i' : '';\r\n\r\n    if (!params?.operator) return `[${attributeKey}=\"${attributeValue}\"${caseInsensitive}]`;\r\n\r\n    switch (params.operator) {\r\n      case 'prefixed':\r\n        return `[${attributeKey}^=\"${attributeValue}\"${caseInsensitive}]`;\r\n      case 'suffixed':\r\n        return `[${attributeKey}$=\"${attributeValue}\"${caseInsensitive}]`;\r\n      case 'contains':\r\n        return `[${attributeKey}*=\"${attributeValue}\"${caseInsensitive}]`;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Queries an element using the generated element selectors.\r\n   * @param elementKey The element key.\r\n   * @param params.instanceIndex Only accepted when the value is dynamic.\r\n   * @param params.operator Optional operator for the selector.\r\n   * @param params.scope The scope for the query. Defaults to `document`.\r\n   * @param params.all determines if array of matched elements should be returned.\r\n   */\r\n  function queryElement<E extends Element = Element, ElementKey extends AttributesValuesKeys = AttributesValuesKeys>(\r\n    elementKey: ElementKey,\r\n    params?: {\r\n      scope?: ParentNode;\r\n      all?: false;\r\n    } & (AttributesValues[ElementKey] extends AttributeStaticValue ? AttributeStaticParams : AttributeDynamicParams)\r\n  ): E | null;\r\n  function queryElement<E extends Element = Element, ElementKey extends AttributesValuesKeys = AttributesValuesKeys>(\r\n    elementKey: ElementKey,\r\n    params?: {\r\n      scope?: ParentNode;\r\n      all: true;\r\n    } & (AttributesValues[ElementKey] extends AttributeStaticValue ? AttributeStaticParams : AttributeDynamicParams)\r\n  ): E[];\r\n  function queryElement<E extends Element = Element, ElementKey extends AttributesValuesKeys = AttributesValuesKeys>(\r\n    elementKey: ElementKey,\r\n    params?: {\r\n      scope?: ParentNode;\r\n      all?: boolean;\r\n    } & (AttributesValues[ElementKey] extends AttributeStaticValue ? AttributeStaticParams : AttributeDynamicParams)\r\n  ): E[] | E | null {\r\n    const selector = getSelector('element', elementKey, params);\r\n    const scope = params?.scope || document;\r\n\r\n    return params?.all ? [...scope.querySelectorAll<E>(selector)] : scope.querySelector<E>(selector);\r\n  }\r\n\r\n  return [getSelector, queryElement] as const;\r\n};\r\n", "import { boolean, optional, record, string, type } from 'superstruct';\r\n\r\nimport { LAUNCHDARKLY_ATTRIBUTE } from '$global/constants/attributes';\r\nimport { generateSelectors } from '$global/factory';\r\n\r\nconst ATTRIBUTES_PREFIX = `fs-${LAUNCHDARKLY_ATTRIBUTE}`;\r\n\r\nexport const LOADER_ELEMENT_KEY = 'loader';\r\nexport const DEV_CLIENT_ID_SETTING_KEY = `devclientid`;\r\nexport const PROD_CLIENT_ID_SETTING_KEY = `prodclientid`;\r\nexport const EVENTS_TO_TRACK_SETTING_KEY = `eventstotrack`;\r\nexport const FLAG_SETTING_KEY = `flag`;\r\nexport const SHOW_IF_SETTING_KEY = `showif`;\r\nexport const SET_PROPERTIES_SETTING_KEY = `setproperties`;\r\nexport const CLOAK_SETTING_KEY = `cloak`;\r\n\r\nexport const ATTRIBUTES = {\r\n  element: {\r\n    key: `${ATTRIBUTES_PREFIX}-element`,\r\n    values: {\r\n      loader: LOADER_ELEMENT_KEY,\r\n    },\r\n  },\r\n\r\n  /**\r\n   * Defines clientId for the LaunchDarkly environment.\r\n   */\r\n  devClientId: {\r\n    key: `${ATTRIBUTES_PREFIX}-${DEV_CLIENT_ID_SETTING_KEY}`,\r\n  },\r\n\r\n  prodClientId: {\r\n    key: `${ATTRIBUTES_PREFIX}-${PROD_CLIENT_ID_SETTING_KEY}`,\r\n  },\r\n\r\n  eventsToTrack: {\r\n    key: `${ATTRIBUTES_PREFIX}-${EVENTS_TO_TRACK_SETTING_KEY}`,\r\n  },\r\n\r\n  flag: {\r\n    key: `${ATTRIBUTES_PREFIX}-${FLAG_SETTING_KEY}`,\r\n  },\r\n\r\n  showIf: {\r\n    key: `${ATTRIBUTES_PREFIX}-${SHOW_IF_SETTING_KEY}`,\r\n  },\r\n\r\n  setProperties: {\r\n    key: `${ATTRIBUTES_PREFIX}-${SET_PROPERTIES_SETTING_KEY}`,\r\n  },\r\n\r\n  cloak: {\r\n    key: `${ATTRIBUTES_PREFIX}-${CLOAK_SETTING_KEY}`,\r\n  },\r\n} as const;\r\n\r\nexport const [getSelector, queryElement] = generateSelectors(ATTRIBUTES);\r\n\r\n/**\r\n * Properties\r\n */\r\nexport const TEXT_PROPERTY = `text`;\r\nexport const SRC_PROPERTY = `src`;\r\nexport const SRCSET_PROPERTY = `srcset`;\r\nexport const SIZES_PROPERTY = `sizes`;\r\nexport const VALUE_PROPERTY = `value`;\r\nexport const CLASS_PROPERTY = `class`;\r\nexport const HTML_PROPERTY = `html`;\r\n\r\n/**\r\n * Defines the JSON Flag Value schema.\r\n */\r\nexport const jsonFlagValueSchema = type({\r\n  show: optional(boolean()),\r\n  properties: optional(record(string(), string())),\r\n});\r\n\r\n/**\r\n * Defines if the current envionment is in the staging domain or in production.\r\n */\r\nexport const IS_STAGING = window.location.origin.includes('webflow.io');\r\n", "import { queryElement } from '../utils/constants';\r\n\r\n/**\r\n * Hides all `fs-launchdarkly-element=\"loader\"` elements.\r\n */\r\nexport const hideLoaders = () => {\r\n  const allElements = queryElement<HTMLElement>('loader', { all: true });\r\n\r\n  for (const element of allElements) {\r\n    element.style.display = 'none';\r\n  }\r\n};\r\n", "import { VALUE_PROPERTY } from './constants';\r\n\r\n/**\r\n * Defines type guards for elements that must support a specific property.\r\n */\r\nexport const PROPERTIES_TYPE_GUARDS = {\r\n  /**\r\n   * Ensures that an element supports the `.value` property.\r\n   * @param element\r\n   */\r\n  [VALUE_PROPERTY](\r\n    element: Element\r\n  ): element is HTMLInputElement | HTMLButtonElement | HTMLSelectElement | HTMLTextAreaElement {\r\n    return (\r\n      element instanceof HTMLInputElement ||\r\n      element instanceof HTMLButtonElement ||\r\n      element instanceof HTMLSelectElement ||\r\n      element instanceof HTMLTextAreaElement\r\n    );\r\n  },\r\n};\r\n", "import {\r\n  SRC_PROPERTY,\r\n  SRCSET_PROPERTY,\r\n  SIZES_PROPERTY,\r\n  TEXT_PROPERTY,\r\n  VALUE_PROPERTY,\r\n  CLASS_PROPERTY,\r\n  HTML_PROPERTY,\r\n} from '../utils/constants';\r\nimport { PROPERTIES_TYPE_GUARDS } from '../utils/type-guards';\r\n\r\n/**\r\n * Updates an element's properties with a value.\r\n * @param element The element to update.\r\n * @param properties The properties of the element to update.\r\n * @param value The value to set to the property.\r\n */\r\nexport const updateElementProperty = (element: HTMLElement, properties: string | string[], value: string): void => {\r\n  const propertiesToUpdate = Array.isArray(properties) ? properties : [properties];\r\n\r\n  for (const property of propertiesToUpdate) {\r\n    propertyActions[property]?.(element, value);\r\n  }\r\n};\r\n\r\n/**\r\n * Defines the actions to update element properties.\r\n */\r\nconst propertyActions: Record<string, (element: HTMLElement, value: string) => void> = {\r\n  [TEXT_PROPERTY]: (element: HTMLElement, value: string) => {\r\n    element.innerText = String(value);\r\n  },\r\n\r\n  [SRC_PROPERTY]: (element: HTMLElement, value: string) => {\r\n    const iframe = element.querySelector('iframe');\r\n    if (iframe) {\r\n      iframe.src = String(value);\r\n      return;\r\n    }\r\n\r\n    element.setAttribute(SRC_PROPERTY, String(value));\r\n    element.removeAttribute(SRCSET_PROPERTY);\r\n  },\r\n\r\n  [SRCSET_PROPERTY]: (element: HTMLElement, value: string) => {\r\n    element.setAttribute(SRCSET_PROPERTY, String(value));\r\n    element.removeAttribute(SRC_PROPERTY);\r\n  },\r\n\r\n  [SIZES_PROPERTY]: (element: HTMLElement, value: string) => {\r\n    element.setAttribute(SIZES_PROPERTY, String(value));\r\n  },\r\n\r\n  [VALUE_PROPERTY]: (element: HTMLElement, value: string) => {\r\n    if (PROPERTIES_TYPE_GUARDS[VALUE_PROPERTY](element)) {\r\n      element.value = String(value);\r\n    }\r\n  },\r\n\r\n  [CLASS_PROPERTY]: (element: HTMLElement, value: string) => {\r\n    element.classList.add(String(value));\r\n  },\r\n\r\n  [HTML_PROPERTY]: (element: HTMLElement, value: string) => {\r\n    element.innerHTML = String(value);\r\n  },\r\n};\r\n", "import { extractCommaSeparatedValues } from '@finsweet/ts-utils';\r\nimport type { LDFlagSet } from 'launchdarkly-js-client-sdk';\r\nimport { is } from 'superstruct';\r\n\r\nimport { updateElementProperty } from './actions/properties';\r\nimport { ATTRIBUTES, getSelector, jsonFlagValueSchema } from './utils/constants';\r\nimport type { JSONFlagValue } from './utils/types';\r\n\r\n/**\r\n * Inits all flag elements.\r\n * Once finished, it removes the `fs-launchdarkly-cloak` of the elements.\r\n * @param flags\r\n */\r\nexport const initFlags = (flags: LDFlagSet) => {\r\n  const allFlagElements = document.querySelectorAll<HTMLElement>(getSelector('flag'));\r\n\r\n  for (const element of allFlagElements) {\r\n    initFlagElement(element, flags);\r\n\r\n    element.removeAttribute(ATTRIBUTES.cloak.key);\r\n  }\r\n};\r\n\r\n/**\r\n * Inits a flag element.\r\n * @param element\r\n * @param flags\r\n */\r\nconst initFlagElement = (element: HTMLElement, flags: LDFlagSet) => {\r\n  const flagName = element.getAttribute(ATTRIBUTES.flag.key);\r\n  if (!flagName) return;\r\n\r\n  const rawFlagValue = flags[flagName];\r\n\r\n  const rawShowIf = element.getAttribute(ATTRIBUTES.showIf.key);\r\n  const rawSetProperties = element.getAttribute(ATTRIBUTES.setProperties.key);\r\n\r\n  // JSON value handling\r\n  if (is(rawFlagValue, jsonFlagValueSchema)) {\r\n    initJSON(element, rawFlagValue);\r\n    return;\r\n  }\r\n\r\n  // Other values handling\r\n  const flagValue =\r\n    typeof rawFlagValue === 'string' || typeof rawFlagValue === 'number' || typeof rawFlagValue === 'boolean'\r\n      ? String(rawFlagValue)\r\n      : undefined;\r\n\r\n  // showif is explicitly defined\r\n  if (rawShowIf) {\r\n    initShowIf(element, rawShowIf, flagValue);\r\n  }\r\n\r\n  // setproperties is explicitly defined\r\n  if (rawSetProperties && flagValue) {\r\n    initSetProperties(element, rawSetProperties, flagValue);\r\n  }\r\n};\r\n\r\n/**\r\n * Inits an element with an explicit `showif` Attribute.\r\n * @param element\r\n * @param rawShowIf\r\n * @param flagValue\r\n */\r\nconst initShowIf = (element: HTMLElement, rawShowIf: string, flagValue?: string) => {\r\n  const showConditions = extractCommaSeparatedValues(rawShowIf);\r\n  const show = !!flagValue && showConditions.includes(flagValue);\r\n\r\n  if (!show) {\r\n    element.remove();\r\n  }\r\n};\r\n\r\n/**\r\n * Inits an element with an explicit `setproperties` Attribute.\r\n * @param element\r\n * @param rawSetProperties\r\n * @param flagValue\r\n */\r\nconst initSetProperties = (element: HTMLElement, rawSetProperties: string, flagValue: string) => {\r\n  const properties = extractCommaSeparatedValues(rawSetProperties);\r\n  updateElementProperty(element, properties, flagValue);\r\n};\r\n\r\n/**\r\n * Inits an element with a JSON flag value.\r\n * @param element\r\n * @param jsonValue\r\n */\r\nconst initJSON = (element: HTMLElement, { show, properties }: JSONFlagValue) => {\r\n  if (show === false) {\r\n    element.remove();\r\n  }\r\n\r\n  if (properties) {\r\n    for (const key in properties) {\r\n      updateElementProperty(element, key, properties[key]);\r\n    }\r\n  }\r\n};\r\n", "/**\r\n * This script is only available in test environment\r\n */\r\nimport { hideLoaders } from './actions/loaders';\r\nimport { initFlags } from './factory';\r\n\r\ndeclare global {\r\n  interface Window {\r\n    fsLaunchDarkly: {\r\n      initFlags: typeof initFlags;\r\n      hideLoaders: typeof hideLoaders;\r\n    };\r\n  }\r\n}\r\n\r\nwindow.fsLaunchDarkly = {\r\n  initFlags,\r\n  hideLoaders,\r\n};\r\n"],
  "mappings": "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",
  "names": ["StructError", "TypeError", "constructor", "failure", "failures", "cached", "message", "rest", "path", "msg", "length", "join", "value", "key", "type", "refinement", "branch", "Object", "assign", "name", "isIterable", "x", "isObject", "Symbol", "iterator", "print", "value", "JSON", "stringify", "shiftIterator", "input", "done", "next", "undefined", "toFailure", "result", "context", "struct", "message", "path", "branch", "type", "refinement", "key", "length", "toFailures", "isIterable", "r", "failure", "run", "options", "coerce", "mask", "ctx", "coercer", "isObject", "schema", "Array", "isArray", "status", "validator", "k", "v", "s", "entries", "ts", "t", "Map", "set", "Set", "add", "refiner", "Struct", "constructor", "props", "TYPE", "assert", "create", "is", "validate", "tuples", "tuple", "error", "StructError", "define", "name", "validator", "Struct", "type", "schema", "boolean", "define", "value", "optional", "struct", "Struct", "validator", "value", "ctx", "undefined", "refiner", "record", "Key", "Value", "type", "schema", "entries", "isObject", "k", "v", "print", "string", "define", "value", "print", "type", "schema", "keys", "Object", "Struct", "entries", "value", "isObject", "k", "validator", "print", "string", "getSelector", "queryElement"]
}
