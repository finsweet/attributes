{
  "version": 3,
  "sources": ["../../node_modules/@finsweet/ts-utils/dist/components/Debug.js", "../../node_modules/@finsweet/ts-utils/dist/webflow/css.js", "../../node_modules/@finsweet/ts-utils/dist/webflow/getSiteId.js", "../../node_modules/@finsweet/ts-utils/dist/webflow/restartWebflow.js", "../../global/factory/selectors.ts", "../../global/constants/attributes.ts", "../../global/factory/assess.ts", "../../global/factory/init.ts", "src/utils/constants.ts", "src/utils/regex.ts", "src/actions/collect.ts", "src/actions/components.ts", "src/actions/html.ts", "src/actions/sanitize.ts", "src/actions/parse.ts", "src/init.ts", "src/index.ts"],
<<<<<<< Updated upstream
  "sourcesContent": ["const alertTypes = ['info', 'error'];\r\nexport class Debug {\r\n    static alertsActivated = false;\r\n    static activateAlerts() {\r\n        this.alertsActivated = true;\r\n    }\r\n    static alert(text, type) {\r\n        if (this.alertsActivated)\r\n            window.alert(text);\r\n        if (type === 'error')\r\n            throw new Error(text);\r\n    }\r\n}\r\n", "export const CURRENT_CSS_CLASS = 'w--current';\r\nexport const RICH_TEXT_BLOCK_CSS_CLASS = 'w-richtext';\r\nexport const HTML_EMBED_CSS_CLASS = 'w-embed';\r\nexport const SLIDER_CSS_CLASSES = {\r\n    slider: 'w-slider',\r\n    slide: 'w-slide',\r\n    sliderMask: 'w-slider-mask',\r\n    sliderNav: 'w-slider-nav',\r\n    sliderDot: 'w-slider-dot',\r\n    activeSliderDot: 'w-active',\r\n};\r\nexport const TABS_CSS_CLASSES = {\r\n    tabs: 'w-tabs',\r\n    tabsContent: 'w-tab-content',\r\n    tabPane: 'w-tab-pane',\r\n    tabsMenu: 'w-tab-menu',\r\n    tabLink: 'w-tab-link',\r\n    activeTab: 'w--tab-active',\r\n};\r\nexport const NAVBAR_CSS_CLASSES = {\r\n    navMenu: 'w-nav-menu',\r\n};\r\nexport const CMS_CSS_CLASSES = {\r\n    wrapper: 'w-dyn-list',\r\n    list: 'w-dyn-items',\r\n    item: 'w-dyn-item',\r\n    paginationWrapper: 'w-pagination-wrapper',\r\n    paginationNext: 'w-pagination-next',\r\n    paginationPrevious: 'w-pagination-previous',\r\n    pageCount: 'w-page-count',\r\n    emptyState: 'w-dyn-empty',\r\n};\r\nexport const FORM_CSS_CLASSES = {\r\n    formBlock: 'w-form',\r\n    checkboxField: 'w-checkbox',\r\n    checkboxInput: 'w-checkbox-input',\r\n    radioField: 'w-radio',\r\n    radioInput: 'w-radio-input',\r\n    checkboxOrRadioLabel: 'w-form-label',\r\n    checkboxOrRadioFocus: 'w--redirected-focus',\r\n    checkboxOrRadioChecked: 'w--redirected-checked',\r\n    successMessage: 'w-form-done',\r\n    errorMessage: 'w-form-fail',\r\n};\r\nexport const DROPDOWN_CSS_CLASSES = {\r\n    dropdown: 'w-dropdown',\r\n    dropdownToggle: 'w-dropdown-toggle',\r\n    dropdownList: 'w-dropdown-list',\r\n};\r\nexport const COMMERCE_CSS_CLASSES = {\r\n    addToCartForm: 'w-commerce-commerceaddtocartform',\r\n};\r\nexport const LIGHTBOX_CSS_CLASSES = {\r\n    trigger: 'w-lightbox',\r\n};\r\n", "export const getSiteId = () => document.documentElement.getAttribute('data-wf-site');\r\n", "import { getSiteId } from '.';\r\nexport const restartWebflow = async (modules) => {\r\n    const { Webflow } = window;\r\n    if (!Webflow || !('destroy' in Webflow) || !('ready' in Webflow) || !('require' in Webflow))\r\n        return;\r\n    if (modules && !modules.length)\r\n        return;\r\n    if (!modules) {\r\n        Webflow.destroy();\r\n        Webflow.ready();\r\n    }\r\n    if (!modules || modules.includes('ix2')) {\r\n        const ix2 = Webflow.require('ix2');\r\n        if (ix2) {\r\n            const { store, actions } = ix2;\r\n            const { eventState } = store.getState().ixSession;\r\n            const stateEntries = Object.entries(eventState);\r\n            if (!modules)\r\n                ix2.destroy();\r\n            ix2.init();\r\n            await Promise.all(stateEntries.map((state) => store.dispatch(actions.eventStateChanged(...state))));\r\n        }\r\n    }\r\n    if (!modules || modules.includes('commerce')) {\r\n        const commerce = Webflow.require('commerce');\r\n        const siteId = getSiteId();\r\n        if (commerce && siteId) {\r\n            commerce.destroy();\r\n            commerce.init({ siteId, apiUrl: 'https://render.webflow.com' });\r\n        }\r\n    }\r\n    if (modules?.includes('lightbox'))\r\n        Webflow.require('lightbox')?.ready();\r\n    if (modules?.includes('slider'))\r\n        Webflow.require('slider')?.redraw();\r\n    if (modules?.includes('tabs'))\r\n        Webflow.require('tabs')?.redraw();\r\n    return new Promise((resolve) => Webflow.push(() => resolve(undefined)));\r\n};\r\n", "import type { AttributeOperator, AttributeStaticValue, AttributeValue } from '$global/types/selectors';\n\n/**\n * Creates a dynamic attribute value.\n * @param value The static attribute value.\n * @returns A callback for generating new attribute values by index.\n */\nexport const generateDynamicAttibuteValue = (value: string) => {\n  return (index?: number): string => `${value}${index ? `-${index}` : ''}`;\n};\n\n/**\n * @returns A `getSelector` callback for the passed `attributes` object.\n * @param attributes An object containing all attribute keys and values.\n */\nexport const generateSelectors = <\n  Attributes extends {\n    [name: string]: {\n      key: string;\n      values?: {\n        [valueKey: string]: AttributeValue;\n      };\n    };\n  }\n>(\n  attributes: Attributes\n) => {\n  /**\n   * Generates a query selector based on the preferences.\n   * @param name The name of the attribute.\n   * @param valueKey The value of the attribute.\n   * @param params.index Only accepted when the value is dynamic.\n   * @param params.operator Optional operator for the selector.\n   * @returns The query selector based on the preferences.\n   */\n  const getSelector = <Name extends keyof Attributes, ValueKey extends keyof Attributes[Name]['values']>(\n    name: Name,\n    valueKey?: ValueKey,\n    params?: Attributes[Name]['values'][ValueKey] extends AttributeStaticValue\n      ? {\n          operator?: AttributeOperator;\n        }\n      : {\n          instanceIndex?: number;\n          operator?: AttributeOperator;\n        }\n  ): string => {\n    const attribute = attributes[name];\n\n    const { key: attributeKey, values } = attribute;\n    let attributeValue: string;\n\n    if (!valueKey) return `[${attributeKey}]`;\n\n    const value = values?.[valueKey] as AttributeValue;\n\n    if (typeof value === 'string') attributeValue = value;\n    else attributeValue = value(params && 'instanceIndex' in params ? params.instanceIndex : undefined);\n\n    if (!params?.operator) return `[${attributeKey}=\"${attributeValue}\"]`;\n\n    switch (params.operator) {\n      case 'prefixed':\n        return `[${attributeKey}^=\"${attributeValue}\"]`;\n      case 'suffixed':\n        return `[${attributeKey}$=\"${attributeValue}\"]`;\n      case 'contains':\n        return `[${attributeKey}*=\"${attributeValue}\"]`;\n    }\n  };\n\n  /**\n   * Queries an element using the generated element selectors.\n   * @param elementKey The element key.\n   * @param params.index Only accepted when the value is dynamic.\n   * @param params.operator Optional operator for the selector.\n   * @param params.scope The scope for the query. Defaults to `document`.\n   */\n  const queryElement = <\n    E extends Element = Element,\n    ElementKey extends keyof Attributes['element']['values'] = keyof Attributes['element']['values']\n  >(\n    elementKey: ElementKey,\n    params?: { scope?: ParentNode } & (Attributes['element']['values'][ElementKey] extends AttributeStaticValue\n      ? {\n          operator?: AttributeOperator;\n        }\n      : {\n          instanceIndex?: number;\n          operator?: AttributeOperator;\n        })\n  ) => {\n    const selector = getSelector('element', elementKey, params);\n\n    return (params?.scope || document).querySelector<E>(selector);\n  };\n\n  return [getSelector, queryElement] as const;\n};\n", "import { generateSelectors } from '$global/factory/selectors';\n\n/**\n * Constants\n */\nexport const ATTRIBUTES_PREFIX = 'fs-attributes';\n\nexport const ATTRIBUTES = {\n  /**\n   * Defines if an Attributes' `<script>` should prevent automatically loading the library.\n   */\n  preventLoad: { key: `${ATTRIBUTES_PREFIX}-preventload` },\n\n  /**\n   * Defines if an Attributes' `<script>` is set to Debug Mode.\n   */\n  debugMode: { key: `${ATTRIBUTES_PREFIX}-debug` },\n\n  /**\n   * Defines the source of an attribute script.\n   */\n  src: { key: 'src', values: { finsweet: '@finsweet/attributes' } },\n\n  /**\n   * Defines a developer script that is not imported from JsDelivr.\n   */\n  dev: { key: `${ATTRIBUTES_PREFIX}-dev` },\n} as const;\n\nexport const [getSelector, queryElement] = generateSelectors(ATTRIBUTES);\n", "import { Debug } from '@finsweet/ts-utils';\n\nimport { ATTRIBUTES } from '../constants/attributes';\nimport { GlobalAttributeParams } from '../types/global';\n\n/**\n * Checks the global params of the Attribute `<script>`.\n * @param script The `<script>` element.\n * @returns The {@link GlobalAttributeParams}.\n */\n\nexport const assessScript = (script: HTMLOrSVGScriptElement | null): GlobalAttributeParams => {\n  const { preventLoad, debugMode } = ATTRIBUTES;\n\n  // Check if the Attribute should not be automatically loaded\n  const preventsLoad = typeof script?.getAttribute(preventLoad.key) === 'string';\n\n  // Check if Debug Mode is activated\n  if (typeof script?.getAttribute(debugMode.key) === 'string') Debug.activateAlerts();\n\n  return { preventsLoad };\n};\n", "import { ATTRIBUTES, getSelector } from '$global/constants/attributes';\r\nimport type { FsAttributes, FsAttributesCallback } from '$global/types/global';\r\n\r\n/**\r\n * Makes sure the window object is defined.\r\n */\r\nexport const initAttributes = () => {\r\n  if (window.fsAttributes && !Array.isArray(window.fsAttributes)) return;\r\n\r\n  const fsAttributes = {\r\n    cms: {},\r\n    push(...args) {\r\n      for (const [attributeName, callback] of args) this[attributeName]?.loading?.then(callback);\r\n    },\r\n  } as FsAttributes;\r\n\r\n  initLoadPromises(fsAttributes);\r\n  runExistingCallbacks(fsAttributes);\r\n\r\n  window.fsAttributes = fsAttributes;\r\n  window.FsAttributes = window.fsAttributes;\r\n};\r\n\r\n/**\r\n * Sets a loading promise for each attribute package.\r\n * @param fsAttributes The {@link FsAttributes} object.\r\n */\r\nconst initLoadPromises = (fsAttributes: FsAttributes) => {\r\n  const srcSelector = getSelector('src', 'finsweet', { operator: 'contains' });\r\n  const devSelector = getSelector('dev');\r\n  const scripts = [...document.querySelectorAll<HTMLScriptElement>(`script${srcSelector}, script${devSelector}`)];\r\n\r\n  const attributes = scripts.reduce<string[]>((acc, script) => {\r\n    const attributeName = script.getAttribute(ATTRIBUTES.dev.key) || script.src.match(/[\\w-. ]+(?=(\\.js)$)/)?.[0];\r\n    if (attributeName && !acc.includes(attributeName)) acc.push(attributeName);\r\n\r\n    return acc;\r\n  }, []);\r\n\r\n  for (const attributeName of attributes) {\r\n    fsAttributes[attributeName] = {};\r\n    const attribute = fsAttributes[attributeName];\r\n\r\n    attribute.loading = new Promise((resolve) => {\r\n      attribute.resolve = (value: unknown) => {\r\n        resolve(value);\r\n        delete attribute.resolve;\r\n      };\r\n    });\r\n  }\r\n};\r\n\r\n/**\r\n * Runs the existing callbacks in the `window.fsAttributes` object.\r\n * @param fsAttributes The {@link FsAttributes} object.\r\n */\r\nconst runExistingCallbacks = (fsAttributes: FsAttributes) => {\r\n  const existingCallbacks = Array.isArray(window.fsAttributes) ? (window.fsAttributes as FsAttributesCallback[]) : [];\r\n  for (const callback of existingCallbacks) fsAttributes.push(callback);\r\n};\r\n", "import { generateSelectors } from '$global/factory/selectors';\r\n\r\nexport const ATTRIBUTE = 'richtext';\r\n\r\nconst ATTRIBUTES_PREFIX = `fs-${ATTRIBUTE}`;\r\n\r\nexport const RICH_TEXT_ELEMENT_KEY = 'rich-text';\r\nexport const COMPONENT_SETTING_KEY = 'component';\r\nexport const SANITIZE_SETTING_KEY = 'sanitize';\r\nexport const RESET_IX_SETTING_KEY = 'reset-ix';\r\n\r\nexport const ATTRIBUTES = {\r\n  element: {\r\n    key: `${ATTRIBUTES_PREFIX}-element`,\r\n    values: {\r\n      /**\r\n       * Defines a rich text block instance.\r\n       */\r\n      richText: RICH_TEXT_ELEMENT_KEY,\r\n    },\r\n  },\r\n\r\n  /**\r\n   * Defines a custom component.\r\n   */\r\n  component: { key: `${ATTRIBUTES_PREFIX}-${COMPONENT_SETTING_KEY}` },\r\n\r\n  /**\r\n   * Defines if the HTML should be sanitized before rendering it.\r\n   */\r\n  sanitize: { key: `${ATTRIBUTES_PREFIX}-${SANITIZE_SETTING_KEY}`, values: { true: 'true' } },\r\n\r\n  /**\r\n   * Defines if Webflow should be restarted after loading new items.\r\n   */\r\n  resetIx: { key: `${ATTRIBUTES_PREFIX}-${RESET_IX_SETTING_KEY}`, values: { true: 'true' } },\r\n} as const;\r\n\r\nexport const [getSelector, queryElement] = generateSelectors(ATTRIBUTES);\r\n\r\nexport const IGNORE_LINE_PREFIX = '&lt;!-- fs-richtext-ignore --&gt;';\r\n\r\nexport const DOMPURIFY_SRC = 'https://cdn.jsdelivr.net/npm/dompurify@2/dist/purify.es.min.js';\r\n", "/**\n * Matches when a string is wrapped between mustache delimiters.\n * @example ```\n * {{component-name}}\n * {{component-name=\"/page-path\"}}\n * ```\n */\nexport const HAS_COMPONENT_TEMPLATE_REGEX = /\\{\\{.*?\\}\\}/;\n\n/**\n * Matches when a string contains a `=\"VALUE\"` pattern.\n * @example =\"/page-path\"\n */\nexport const IS_EXTERNAL_COMPONENT_REGEX = /\\=\\\".*?\\\"/;\n\n/**\n * Matches when a string contains a `<` and a `>`.\n * @example```\n * <div class=\"test\"> // Matches!\n * The quick brown <span style=\"red\">fox</span>. // Matches!\n * ```\n */\nexport const HAS_HTML_OPENING_TAG_REGEX = /\\&lt\\;.*?\\&gt\\;/;\n\n/**\n * Matches when a string starts with `<` and ends with `>`.\n * @example```\n * <div class=\"test\"> // Matches!\n * The quick brown <span style=\"red\">fox</span>. // Doesn't match!\n * ```\n */\nexport const IS_HTML_OPENING_TAG_REGEX = /^\\&lt\\;.*?\\&gt\\;$/;\n\n/**\n * Matches when a string ends with a trailing slash.\n * @example https://www.finsweet.com/\n */\nexport const TRAILING_SLASH_REGEX = /\\/+$/;\n\n/**\n * Matches the mustache delimiters in the component template.\n * @example {{component-name=\"/page-path\"}} // Will match the {{ }} delimiters\n */\nexport const MUSTACHE_DELIMITERS_REGEX = /(\\{\\{)|(\\}\\})/g;\n", "import { HTML_EMBED_CSS_CLASS } from '@finsweet/ts-utils';\r\n\r\nimport { IGNORE_LINE_PREFIX } from '../utils/constants';\r\nimport { HAS_COMPONENT_TEMPLATE_REGEX, HAS_HTML_OPENING_TAG_REGEX } from '../utils/regex';\r\nimport { TextElement } from '../utils/types';\r\n\r\n/**\r\n * Queries all the valid paragraphs.\r\n * Removes the {@link IGNORE_LINE_PREFIX} from the matched paragraphs.\r\n * @returns All the valid paragraphs.\r\n * @param element The Rich Text Block element.\r\n */\r\nexport const getValidTextElements = (element: Element): TextElement[] => {\r\n  const textElements = [...element.querySelectorAll<TextElement>('h1, h2, h3, h4, h5, h6, p, blockquote, li')];\r\n\r\n  const filteredParagraphs = textElements.filter((paragraph) => {\r\n    const { innerHTML } = paragraph;\r\n    if (!innerHTML) return false;\r\n\r\n    const mustIgnore = innerHTML.includes(IGNORE_LINE_PREFIX);\r\n    const hasComponent = HAS_COMPONENT_TEMPLATE_REGEX.test(innerHTML);\r\n    const hasTag = HAS_HTML_OPENING_TAG_REGEX.test(innerHTML);\r\n    const isEmbed = paragraph.closest(`.${HTML_EMBED_CSS_CLASS}`);\r\n\r\n    if (mustIgnore) {\r\n      paragraph.innerHTML = innerHTML.replace(IGNORE_LINE_PREFIX, '');\r\n      return false;\r\n    }\r\n\r\n    return (hasTag || hasComponent) && !isEmbed;\r\n  });\r\n\r\n  return filteredParagraphs;\r\n};\r\n", "import { Debug } from '@finsweet/ts-utils';\n\nimport { ATTRIBUTES } from '../utils/constants';\nimport {\n  HAS_COMPONENT_TEMPLATE_REGEX,\n  IS_EXTERNAL_COMPONENT_REGEX,\n  MUSTACHE_DELIMITERS_REGEX,\n  TRAILING_SLASH_REGEX,\n} from '../utils/regex';\n\n/**\n * Memoizes the queried components.\n */\nconst componentsStore: Array<{ element: HTMLElement; componentKey: string; source?: string }> = [];\n\nconst { origin, href: currentHref } = window.location;\n\n/**\n *\n * @returns The `outterHTML` of a component based on the templating syntax:\n * @param rawHTML The raw HTML containing the templating syntax.\n * @example ```\n * {{component-name}} // A component with `fs-richtext-component=\"component-name\"` will be queried on the same page.\n * {{component-name=\"/page-path\"}} // A component with `fs-richtext-component=\"component-name\"` will be queried on the `/page-path` page.\n * ```\n */\nexport const getComponentHTML = async (rawHTML: string): Promise<string | undefined> => {\n  const [componentDefinition] = rawHTML.match(HAS_COMPONENT_TEMPLATE_REGEX) || [];\n  if (!componentDefinition) return;\n\n  const rawComponentKey = componentDefinition.replace(MUSTACHE_DELIMITERS_REGEX, '').trim();\n\n  const isExternal = IS_EXTERNAL_COMPONENT_REGEX.test(rawComponentKey);\n\n  if (!isExternal) {\n    const component = await queryComponent(rawComponentKey);\n    return component?.outerHTML;\n  }\n\n  const [componentKey] = rawComponentKey.split('=\"');\n  const [rawSource] = rawComponentKey.match(IS_EXTERNAL_COMPONENT_REGEX) || [];\n\n  if (!componentKey || !rawSource) return;\n\n  const source = parseComponentSource(rawSource);\n  const component = await queryComponent(componentKey, source);\n\n  return component?.outerHTML;\n};\n\n/**\n * Extracts an external source from a component key.\n * @param rawSource The component's source.\n * @example\n * {{component-name=\"https://example.com/page-path\"}} // Will return https://example.com/page-path\n * {{component-name=\"/page-path\"}} // Will also return https://example.com/page-path\n *\n * @returns The source, if valid.\n */\nconst parseComponentSource = (rawSource: string) => {\n  let source = rawSource.replace('=\"', '').replace('\"', '').trim();\n\n  if (source.startsWith('/')) source = origin.replace(TRAILING_SLASH_REGEX, '') + source;\n\n  const { href: sourceHref } = new URL(source);\n\n  const validSource = currentHref !== sourceHref;\n\n  if (validSource) return source;\n};\n\n/**\n * Queries a component by key.\n * @param componentKey The key of the component.\n * @param source A external source where the component is located.\n * @returns The component node, if existing.\n */\nconst queryComponent = async (componentKey: string, source?: string): Promise<HTMLElement | null | undefined> => {\n  const storedComponent = componentsStore.find((data) => data.componentKey === componentKey && data.source === source);\n  if (storedComponent) return storedComponent.element;\n\n  let externalDocument: Document | undefined;\n\n  if (source) {\n    try {\n      const response = await fetch(source);\n      const data = await response.text();\n\n      const parser = new DOMParser();\n      externalDocument = parser.parseFromString(data, 'text/html');\n    } catch (error) {\n      Debug.alert(`[${source}] is not a valid source.`, 'error');\n      return;\n    }\n  }\n\n  const element = (externalDocument || document).querySelector<HTMLElement>(\n    `[${ATTRIBUTES.component.key}=\"${componentKey}\"]`\n  );\n\n  if (!element) Debug.alert(`No components were found with the [${componentKey}] key.`, 'info');\n\n  if (element) {\n    componentsStore.push({\n      element,\n      componentKey,\n      source,\n    });\n\n    element.remove();\n  }\n\n  return element;\n};\n", "/**\r\n * Replaces escaped HTML symbols with their original value.\r\n * @param rawHTML The raw HTML to unescape.\r\n */\r\nexport const unescapeHTML = (rawHTML: string): string => {\r\n  return rawHTML\r\n    .replace(/(&nbsp;)/g, ' ')\r\n    .replace(/(&lt;)/g, '<')\r\n    .replace(/(&gt;)/g, '>')\r\n    .replace(/(&amp;)/g, '&')\r\n    .replace(/(&quot;)/g, '\"')\r\n    .replace(/(&#96;)/g, '`')\r\n    .replace(/(&#x27;)/g, \"'\");\r\n};\r\n", "/// <reference types=\"@types/dompurify\" />\nimport { Debug } from '@finsweet/ts-utils';\n\nimport { DOMPURIFY_SRC } from '../utils/constants';\n\nlet DOMPurify: DOMPurify.DOMPurifyI | undefined;\n\n/**\n * Dynamically imports `DOMPurify` and memoizes the library.\n */\nconst importDOMPurify = async (): Promise<DOMPurify.DOMPurifyI | undefined> => {\n  if (DOMPurify) return DOMPurify;\n\n  try {\n    const module: { default: DOMPurify.DOMPurifyI } = await import(DOMPURIFY_SRC);\n\n    DOMPurify = module.default;\n\n    return DOMPurify;\n  } catch (error) {\n    Debug.alert('There was an issue while importing DOMPurify.', 'info');\n    return;\n  }\n};\n\n/**\n * Sanitizes an HTML string with `DOMPurify`.\n * @param rawHTML The HTML string to sanitize.\n */\nexport const sanitizeHTML = async (rawHTML: string): Promise<string> => {\n  const DOMPurify = await importDOMPurify();\n  if (!DOMPurify) return '';\n\n  return DOMPurify.sanitize(rawHTML);\n};\n", "import { HAS_COMPONENT_TEMPLATE_REGEX, IS_HTML_OPENING_TAG_REGEX } from '../utils/regex';\r\nimport type { TextElement } from '../utils/types';\r\nimport { getComponentHTML } from './components';\r\nimport { unescapeHTML } from './html';\r\nimport { sanitizeHTML } from './sanitize';\r\n\r\n/**\r\n * Parses the content of a text element and converts it to valid HTML.\r\n * @param textElement The {@link TextElement}.\r\n * @param sanitize Defines if the text content should be sanitized before parsing the HTML.\r\n */\r\nexport const parseTextElement = async (textElement: TextElement, sanitize: boolean) => {\r\n  const { innerHTML } = textElement;\r\n  const isComponent = HAS_COMPONENT_TEMPLATE_REGEX.test(innerHTML);\r\n\r\n  if (isComponent) {\r\n    const componentHTML = await getComponentHTML(innerHTML);\r\n    if (componentHTML) textElement.outerHTML = componentHTML;\r\n\r\n    return;\r\n  }\r\n\r\n  const isTag = textElement.tagName === 'P' && IS_HTML_OPENING_TAG_REGEX.test(innerHTML.trim());\r\n  const unescapedHTML = unescapeHTML(innerHTML);\r\n\r\n  textElement[isTag ? 'outerHTML' : 'innerHTML'] = sanitize ? await sanitizeHTML(unescapedHTML) : unescapedHTML;\r\n};\r\n", "import { restartWebflow, RICH_TEXT_BLOCK_CSS_CLASS } from '@finsweet/ts-utils';\r\nimport type { RichTextBlockElement } from '@finsweet/ts-utils';\r\n\r\nimport { getValidTextElements } from './actions/collect';\r\nimport { parseTextElement } from './actions/parse';\r\nimport { ATTRIBUTES, getSelector } from './utils/constants';\r\n\r\n// Constants\r\nconst {\r\n  sanitize: { key: sanitizeKey, values: sanitizeValues },\r\n  resetIx: { key: resetIxKey, values: resetIxValues },\r\n} = ATTRIBUTES;\r\n\r\n/**\r\n * Inits the attribute.\r\n */\r\nexport const init = (): void => {\r\n  const rtbElements = document.querySelectorAll<RichTextBlockElement>(\r\n    `.${RICH_TEXT_BLOCK_CSS_CLASS}${getSelector('element', 'richText', { operator: 'prefixed' })}`\r\n  );\r\n\r\n  for (const rtbElement of rtbElements) initRtbElement(rtbElement);\r\n};\r\n\r\n/**\r\n * Inits a Rich Text Block element, replacing HTML strings for their parsed version, and component templates for the component nodes.\r\n * @param element\r\n */\r\nconst initRtbElement = async (element: RichTextBlockElement) => {\r\n  const sanitize = element.getAttribute(sanitizeKey) === sanitizeValues.true;\r\n  const resetIx = element.getAttribute(resetIxKey) === resetIxValues.true;\r\n  const textElements = getValidTextElements(element);\r\n\r\n  await Promise.all(textElements.map((textElement) => parseTextElement(textElement, sanitize)));\r\n\r\n  if (resetIx) await restartWebflow(['ix2']);\r\n};\r\n", "import { assessScript } from '$global/factory/assess';\r\nimport { initAttributes } from '$global/factory/init';\r\n\r\nimport { init } from './init';\r\nimport { ATTRIBUTE } from './utils/constants';\r\n\r\n/**\r\n * Init\r\n */\r\ninitAttributes();\r\n\r\nconst { currentScript } = document;\r\nconst { preventsLoad } = assessScript(currentScript);\r\n\r\nif (preventsLoad) window.fsAttributes[ATTRIBUTE] = { init };\r\nelse {\r\n  window.Webflow ||= [];\r\n  window.Webflow.push(init);\r\n}\r\n"],
  "mappings": "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",
=======
  "sourcesContent": ["const alertTypes = ['info', 'error'];\r\nexport class Debug {\r\n    static alertsActivated = false;\r\n    static activateAlerts() {\r\n        this.alertsActivated = true;\r\n    }\r\n    static alert(text, type) {\r\n        if (this.alertsActivated)\r\n            window.alert(text);\r\n        if (type === 'error')\r\n            throw new Error(text);\r\n    }\r\n}\r\n", "export const CURRENT_CSS_CLASS = 'w--current';\r\nexport const RICH_TEXT_BLOCK_CSS_CLASS = 'w-richtext';\r\nexport const HTML_EMBED_CSS_CLASS = 'w-embed';\r\nexport const SLIDER_CSS_CLASSES = {\r\n    slider: 'w-slider',\r\n    slide: 'w-slide',\r\n    sliderMask: 'w-slider-mask',\r\n    sliderNav: 'w-slider-nav',\r\n    sliderDot: 'w-slider-dot',\r\n    activeSliderDot: 'w-active',\r\n};\r\nexport const TABS_CSS_CLASSES = {\r\n    tabs: 'w-tabs',\r\n    tabsContent: 'w-tab-content',\r\n    tabPane: 'w-tab-pane',\r\n    tabsMenu: 'w-tab-menu',\r\n    tabLink: 'w-tab-link',\r\n    activeTab: 'w--tab-active',\r\n};\r\nexport const NAVBAR_CSS_CLASSES = {\r\n    navMenu: 'w-nav-menu',\r\n};\r\nexport const CMS_CSS_CLASSES = {\r\n    wrapper: 'w-dyn-list',\r\n    list: 'w-dyn-items',\r\n    item: 'w-dyn-item',\r\n    paginationWrapper: 'w-pagination-wrapper',\r\n    paginationNext: 'w-pagination-next',\r\n    paginationPrevious: 'w-pagination-previous',\r\n    pageCount: 'w-page-count',\r\n    emptyState: 'w-dyn-empty',\r\n};\r\nexport const FORM_CSS_CLASSES = {\r\n    formBlock: 'w-form',\r\n    checkboxField: 'w-checkbox',\r\n    checkboxInput: 'w-checkbox-input',\r\n    radioField: 'w-radio',\r\n    radioInput: 'w-radio-input',\r\n    checkboxOrRadioLabel: 'w-form-label',\r\n    checkboxOrRadioFocus: 'w--redirected-focus',\r\n    checkboxOrRadioChecked: 'w--redirected-checked',\r\n    successMessage: 'w-form-done',\r\n    errorMessage: 'w-form-fail',\r\n};\r\nexport const DROPDOWN_CSS_CLASSES = {\r\n    dropdown: 'w-dropdown',\r\n    dropdownToggle: 'w-dropdown-toggle',\r\n    dropdownList: 'w-dropdown-list',\r\n};\r\nexport const COMMERCE_CSS_CLASSES = {\r\n    addToCartForm: 'w-commerce-commerceaddtocartform',\r\n};\r\nexport const LIGHTBOX_CSS_CLASSES = {\r\n    trigger: 'w-lightbox',\r\n};\r\n", "export const getSiteId = () => document.documentElement.getAttribute('data-wf-site');\r\n", "import { getSiteId } from '.';\r\nexport const restartWebflow = async (modules) => {\r\n    const { Webflow } = window;\r\n    if (!Webflow || !('destroy' in Webflow) || !('ready' in Webflow) || !('require' in Webflow))\r\n        return;\r\n    if (modules && !modules.length)\r\n        return;\r\n    if (!modules) {\r\n        Webflow.destroy();\r\n        Webflow.ready();\r\n    }\r\n    if (!modules || modules.includes('ix2')) {\r\n        const ix2 = Webflow.require('ix2');\r\n        if (ix2) {\r\n            const { store, actions } = ix2;\r\n            const { eventState } = store.getState().ixSession;\r\n            const stateEntries = Object.entries(eventState);\r\n            if (!modules)\r\n                ix2.destroy();\r\n            ix2.init();\r\n            await Promise.all(stateEntries.map((state) => store.dispatch(actions.eventStateChanged(...state))));\r\n        }\r\n    }\r\n    if (!modules || modules.includes('commerce')) {\r\n        const commerce = Webflow.require('commerce');\r\n        const siteId = getSiteId();\r\n        if (commerce && siteId) {\r\n            commerce.destroy();\r\n            commerce.init({ siteId, apiUrl: 'https://render.webflow.com' });\r\n        }\r\n    }\r\n    if (modules?.includes('lightbox'))\r\n        Webflow.require('lightbox')?.ready();\r\n    if (modules?.includes('slider'))\r\n        Webflow.require('slider')?.redraw();\r\n    if (modules?.includes('tabs'))\r\n        Webflow.require('tabs')?.redraw();\r\n    return new Promise((resolve) => Webflow.push(() => resolve(undefined)));\r\n};\r\n", "import type { AttributeOperator, AttributeStaticValue, AttributeValue } from '$global/types/selectors';\n\n/**\n * Creates a dynamic attribute value.\n * @param value The static attribute value.\n * @returns A callback for generating new attribute values by index.\n */\nexport const generateDynamicAttibuteValue = (value: string) => {\n  return (index?: number): string => `${value}${index ? `-${index}` : ''}`;\n};\n\n/**\n * @returns A `getSelector` callback for the passed `attributes` object.\n * @param attributes An object containing all attribute keys and values.\n */\nexport const generateSelectors = <\n  Attributes extends {\n    [name: string]: {\n      key: string;\n      values?: {\n        [valueKey: string]: AttributeValue;\n      };\n    };\n  }\n>(\n  attributes: Attributes\n) => {\n  /**\n   * Generates a query selector based on the preferences.\n   * @param name The name of the attribute.\n   * @param valueKey The value of the attribute.\n   * @param params.index Only accepted when the value is dynamic.\n   * @param params.operator Optional operator for the selector.\n   * @returns The query selector based on the preferences.\n   */\n  const getSelector = <Name extends keyof Attributes, ValueKey extends keyof Attributes[Name]['values']>(\n    name: Name,\n    valueKey?: ValueKey,\n    params?: Attributes[Name]['values'][ValueKey] extends AttributeStaticValue\n      ? {\n          operator?: AttributeOperator;\n        }\n      : {\n          instanceIndex?: number;\n          operator?: AttributeOperator;\n        }\n  ): string => {\n    const attribute = attributes[name];\n\n    const { key: attributeKey, values } = attribute;\n    let attributeValue: string;\n\n    if (!valueKey) return `[${attributeKey}]`;\n\n    const value = values?.[valueKey] as AttributeValue;\n\n    if (typeof value === 'string') attributeValue = value;\n    else attributeValue = value(params && 'instanceIndex' in params ? params.instanceIndex : undefined);\n\n    if (!params?.operator) return `[${attributeKey}=\"${attributeValue}\"]`;\n\n    switch (params.operator) {\n      case 'prefixed':\n        return `[${attributeKey}^=\"${attributeValue}\"]`;\n      case 'suffixed':\n        return `[${attributeKey}$=\"${attributeValue}\"]`;\n      case 'contains':\n        return `[${attributeKey}*=\"${attributeValue}\"]`;\n    }\n  };\n\n  /**\n   * Queries an element using the generated element selectors.\n   * @param elementKey The element key.\n   * @param params.index Only accepted when the value is dynamic.\n   * @param params.operator Optional operator for the selector.\n   * @param params.scope The scope for the query. Defaults to `document`.\n   */\n  const queryElement = <\n    E extends Element = Element,\n    ElementKey extends keyof Attributes['element']['values'] = keyof Attributes['element']['values']\n  >(\n    elementKey: ElementKey,\n    params?: { scope?: ParentNode } & (Attributes['element']['values'][ElementKey] extends AttributeStaticValue\n      ? {\n          operator?: AttributeOperator;\n        }\n      : {\n          instanceIndex?: number;\n          operator?: AttributeOperator;\n        })\n  ) => {\n    const selector = getSelector('element', elementKey, params);\n\n    return (params?.scope || document).querySelector<E>(selector);\n  };\n\n  return [getSelector, queryElement] as const;\n};\n", "import { generateSelectors } from '$global/factory/selectors';\n\n/**\n * Constants\n */\nexport const ATTRIBUTES_PREFIX = 'fs-attributes';\n\nexport const ATTRIBUTES = {\n  /**\n   * Defines if an Attributes' `<script>` should prevent automatically loading the library.\n   */\n  preventLoad: { key: `${ATTRIBUTES_PREFIX}-preventload` },\n\n  /**\n   * Defines if an Attributes' `<script>` is set to Debug Mode.\n   */\n  debugMode: { key: `${ATTRIBUTES_PREFIX}-debug` },\n\n  /**\n   * Defines the source of an attribute script.\n   */\n  src: { key: 'src', values: { finsweet: '@finsweet/attributes' } },\n\n  /**\n   * Defines a developer script that is not imported from JsDelivr.\n   */\n  dev: { key: `${ATTRIBUTES_PREFIX}-dev` },\n} as const;\n\nexport const [getSelector, queryElement] = generateSelectors(ATTRIBUTES);\n", "import { Debug } from '@finsweet/ts-utils';\n\nimport { ATTRIBUTES } from '../constants/attributes';\nimport { GlobalAttributeParams } from '../types/global';\n\n/**\n * Checks the global params of the Attribute `<script>`.\n * @param script The `<script>` element.\n * @returns The {@link GlobalAttributeParams}.\n */\n\nexport const assessScript = (script: HTMLOrSVGScriptElement | null): GlobalAttributeParams => {\n  const { preventLoad, debugMode } = ATTRIBUTES;\n\n  // Check if the Attribute should not be automatically loaded\n  const preventsLoad = typeof script?.getAttribute(preventLoad.key) === 'string';\n\n  // Check if Debug Mode is activated\n  if (typeof script?.getAttribute(debugMode.key) === 'string') Debug.activateAlerts();\n\n  return { preventsLoad };\n};\n", "import { ATTRIBUTES, getSelector } from '$global/constants/attributes';\r\nimport type { FsAttributes, FsAttributesCallback } from '$global/types/global';\r\n\r\n/**\r\n * Makes sure the window object is defined.\r\n */\r\nexport const initAttributes = () => {\r\n  if (window.fsAttributes && !Array.isArray(window.fsAttributes)) return;\r\n\r\n  const fsAttributes = {\r\n    cms: {},\r\n    push(...args) {\r\n      for (const [attributeName, callback] of args) this[attributeName]?.loading?.then(callback);\r\n    },\r\n  } as FsAttributes;\r\n\r\n  initLoadPromises(fsAttributes);\r\n  runExistingCallbacks(fsAttributes);\r\n\r\n  window.fsAttributes = fsAttributes;\r\n  window.FsAttributes = window.fsAttributes;\r\n};\r\n\r\n/**\r\n * Sets a loading promise for each attribute package.\r\n * @param fsAttributes The {@link FsAttributes} object.\r\n */\r\nconst initLoadPromises = (fsAttributes: FsAttributes) => {\r\n  const srcSelector = getSelector('src', 'finsweet', { operator: 'contains' });\r\n  const devSelector = getSelector('dev');\r\n  const scripts = [...document.querySelectorAll<HTMLScriptElement>(`script${srcSelector}, script${devSelector}`)];\r\n\r\n  const attributes = scripts.reduce<string[]>((acc, script) => {\r\n    const attributeName = script.getAttribute(ATTRIBUTES.dev.key) || script.src.match(/[\\w-. ]+(?=(\\.js)$)/)?.[0];\r\n    if (attributeName && !acc.includes(attributeName)) acc.push(attributeName);\r\n\r\n    return acc;\r\n  }, []);\r\n\r\n  for (const attributeName of attributes) {\r\n    fsAttributes[attributeName] = {};\r\n    const attribute = fsAttributes[attributeName];\r\n\r\n    attribute.loading = new Promise((resolve) => {\r\n      attribute.resolve = (value: unknown) => {\r\n        resolve(value);\r\n        delete attribute.resolve;\r\n      };\r\n    });\r\n  }\r\n};\r\n\r\n/**\r\n * Runs the existing callbacks in the `window.fsAttributes` object.\r\n * @param fsAttributes The {@link FsAttributes} object.\r\n */\r\nconst runExistingCallbacks = (fsAttributes: FsAttributes) => {\r\n  const existingCallbacks = Array.isArray(window.fsAttributes) ? (window.fsAttributes as FsAttributesCallback[]) : [];\r\n  for (const callback of existingCallbacks) fsAttributes.push(callback);\r\n};\r\n", "import { generateSelectors } from '$global/factory/selectors';\r\n\r\nexport const ATTRIBUTE = 'richtext';\r\n\r\nconst ATTRIBUTES_PREFIX = `fs-${ATTRIBUTE}`;\r\n\r\nexport const RICH_TEXT_ELEMENT_KEY = 'rich-text';\r\nexport const COMPONENT_SETTING_KEY = 'component';\r\nexport const SANITIZE_SETTING_KEY = 'sanitize';\r\nexport const RESET_IX_SETTING_KEY = 'reset-ix';\r\n\r\nexport const ATTRIBUTES = {\r\n  element: {\r\n    key: `${ATTRIBUTES_PREFIX}-element`,\r\n    values: {\r\n      /**\r\n       * Defines a rich text block instance.\r\n       */\r\n      richText: RICH_TEXT_ELEMENT_KEY,\r\n    },\r\n  },\r\n\r\n  /**\r\n   * Defines a custom component.\r\n   */\r\n  component: { key: `${ATTRIBUTES_PREFIX}-${COMPONENT_SETTING_KEY}` },\r\n\r\n  /**\r\n   * Defines if the HTML should be sanitized before rendering it.\r\n   */\r\n  sanitize: { key: `${ATTRIBUTES_PREFIX}-${SANITIZE_SETTING_KEY}`, values: { true: 'true' } },\r\n\r\n  /**\r\n   * Defines if Webflow should be restarted after loading new items.\r\n   */\r\n  resetIx: { key: `${ATTRIBUTES_PREFIX}-${RESET_IX_SETTING_KEY}`, values: { true: 'true' } },\r\n} as const;\r\n\r\nexport const [getSelector, queryElement] = generateSelectors(ATTRIBUTES);\r\n\r\nexport const IGNORE_LINE_PREFIX = '&lt;!-- fs-richtext-ignore --&gt;';\r\n\r\nexport const DOMPURIFY_SRC = 'https://cdn.jsdelivr.net/npm/dompurify@2/dist/purify.es.min.js';\r\n", "/**\n * Matches when a string is wrapped between mustache delimiters.\n * @example ```\n * {{component-name}}\n * {{component-name=\"/page-path\"}}\n * ```\n */\nexport const HAS_COMPONENT_TEMPLATE_REGEX = /\\{\\{.*?\\}\\}/;\n\n/**\n * Matches when a string contains a `=\"VALUE\"` pattern.\n * @example =\"/page-path\"\n */\nexport const IS_EXTERNAL_COMPONENT_REGEX = /\\=\\\".*?\\\"/;\n\n/**\n * Matches when a string contains a `<` and a `>`.\n * @example```\n * <div class=\"test\"> // Matches!\n * The quick brown <span style=\"red\">fox</span>. // Matches!\n * ```\n */\nexport const HAS_HTML_OPENING_TAG_REGEX = /\\&lt\\;.*?\\&gt\\;/;\n\n/**\n * Matches when a string starts with `<` and ends with `>`.\n * @example```\n * <div class=\"test\"> // Matches!\n * The quick brown <span style=\"red\">fox</span>. // Doesn't match!\n * ```\n */\nexport const IS_HTML_OPENING_TAG_REGEX = /^\\&lt\\;.*?\\&gt\\;$/;\n\n/**\n * Matches when a string ends with a trailing slash.\n * @example https://www.finsweet.com/\n */\nexport const TRAILING_SLASH_REGEX = /\\/+$/;\n\n/**\n * Matches the mustache delimiters in the component template.\n * @example {{component-name=\"/page-path\"}} // Will match the {{ }} delimiters\n */\nexport const MUSTACHE_DELIMITERS_REGEX = /(\\{\\{)|(\\}\\})/g;\n", "import { HTML_EMBED_CSS_CLASS } from '@finsweet/ts-utils';\r\n\r\nimport { IGNORE_LINE_PREFIX } from '../utils/constants';\r\nimport { HAS_COMPONENT_TEMPLATE_REGEX, HAS_HTML_OPENING_TAG_REGEX } from '../utils/regex';\r\nimport { TextElement } from '../utils/types';\r\n\r\n/**\r\n * Queries all the valid paragraphs.\r\n * Removes the {@link IGNORE_LINE_PREFIX} from the matched paragraphs.\r\n * @returns All the valid paragraphs.\r\n * @param element The Rich Text Block element.\r\n */\r\nexport const getValidTextElements = (element: Element): TextElement[] => {\r\n  const textElements = [...element.querySelectorAll<TextElement>('h1, h2, h3, h4, h5, h6, p, blockquote, li')];\r\n\r\n  const filteredParagraphs = textElements.filter((paragraph) => {\r\n    const { innerHTML } = paragraph;\r\n    if (!innerHTML) return false;\r\n\r\n    const mustIgnore = innerHTML.includes(IGNORE_LINE_PREFIX);\r\n    const hasComponent = HAS_COMPONENT_TEMPLATE_REGEX.test(innerHTML);\r\n    const hasTag = HAS_HTML_OPENING_TAG_REGEX.test(innerHTML);\r\n    const isEmbed = paragraph.closest(`.${HTML_EMBED_CSS_CLASS}`);\r\n\r\n    if (mustIgnore) {\r\n      paragraph.innerHTML = innerHTML.replace(IGNORE_LINE_PREFIX, '');\r\n      return false;\r\n    }\r\n\r\n    return (hasTag || hasComponent) && !isEmbed;\r\n  });\r\n\r\n  return filteredParagraphs;\r\n};\r\n", "import { Debug } from '@finsweet/ts-utils';\n\nimport { ATTRIBUTES } from '../utils/constants';\nimport {\n  HAS_COMPONENT_TEMPLATE_REGEX,\n  IS_EXTERNAL_COMPONENT_REGEX,\n  MUSTACHE_DELIMITERS_REGEX,\n  TRAILING_SLASH_REGEX,\n} from '../utils/regex';\n\n/**\n * Memoizes the queried components.\n */\nconst componentsStore: Array<{ element: HTMLElement; componentKey: string; source?: string }> = [];\n\nconst { origin, href: currentHref } = window.location;\n\n/**\n *\n * @returns The `outterHTML` of a component based on the templating syntax:\n * @param rawHTML The raw HTML containing the templating syntax.\n * @example ```\n * {{component-name}} // A component with `fs-richtext-component=\"component-name\"` will be queried on the same page.\n * {{component-name=\"/page-path\"}} // A component with `fs-richtext-component=\"component-name\"` will be queried on the `/page-path` page.\n * ```\n */\nexport const getComponentHTML = async (rawHTML: string): Promise<string | undefined> => {\n  const [componentDefinition] = rawHTML.match(HAS_COMPONENT_TEMPLATE_REGEX) || [];\n  if (!componentDefinition) return;\n\n  const rawComponentKey = componentDefinition.replace(MUSTACHE_DELIMITERS_REGEX, '').trim();\n\n  const isExternal = IS_EXTERNAL_COMPONENT_REGEX.test(rawComponentKey);\n\n  if (!isExternal) {\n    const component = await queryComponent(rawComponentKey);\n    return component?.outerHTML;\n  }\n\n  const [componentKey] = rawComponentKey.split('=\"');\n  const [rawSource] = rawComponentKey.match(IS_EXTERNAL_COMPONENT_REGEX) || [];\n\n  if (!componentKey || !rawSource) return;\n\n  const source = parseComponentSource(rawSource);\n  const component = await queryComponent(componentKey, source);\n\n  return component?.outerHTML;\n};\n\n/**\n * Extracts an external source from a component key.\n * @param rawSource The component's source.\n * @example\n * {{component-name=\"https://example.com/page-path\"}} // Will return https://example.com/page-path\n * {{component-name=\"/page-path\"}} // Will also return https://example.com/page-path\n *\n * @returns The source, if valid.\n */\nconst parseComponentSource = (rawSource: string) => {\n  let source = rawSource.replace('=\"', '').replace('\"', '').trim();\n\n  if (source.startsWith('/')) source = origin.replace(TRAILING_SLASH_REGEX, '') + source;\n\n  const { href: sourceHref } = new URL(source);\n\n  const validSource = currentHref !== sourceHref;\n\n  if (validSource) return source;\n};\n\n/**\n * Queries a component by key.\n * @param componentKey The key of the component.\n * @param source A external source where the component is located.\n * @returns The component node, if existing.\n */\nconst queryComponent = async (componentKey: string, source?: string): Promise<HTMLElement | null | undefined> => {\n  const storedComponent = componentsStore.find((data) => data.componentKey === componentKey && data.source === source);\n  if (storedComponent) return storedComponent.element;\n\n  let externalDocument: Document | undefined;\n\n  if (source) {\n    try {\n      const response = await fetch(source);\n      const data = await response.text();\n\n      const parser = new DOMParser();\n      externalDocument = parser.parseFromString(data, 'text/html');\n    } catch (error) {\n      Debug.alert(`[${source}] is not a valid source.`, 'error');\n      return;\n    }\n  }\n\n  const element = (externalDocument || document).querySelector<HTMLElement>(\n    `[${ATTRIBUTES.component.key}=\"${componentKey}\"]`\n  );\n\n  if (!element) Debug.alert(`No components were found with the [${componentKey}] key.`, 'info');\n\n  if (element) {\n    componentsStore.push({\n      element,\n      componentKey,\n      source,\n    });\n\n    element.remove();\n  }\n\n  return element;\n};\n", "/**\r\n * Replaces escaped HTML symbols with their original value.\r\n * @param rawHTML The raw HTML to unescape.\r\n */\r\nexport const unescapeHTML = (rawHTML: string): string => {\r\n  return rawHTML\r\n    .replace(/(&nbsp;)/g, ' ')\r\n    .replace(/(&lt;)/g, '<')\r\n    .replace(/(&gt;)/g, '>')\r\n    .replace(/(&amp;)/g, '&')\r\n    .replace(/(&quot;)/g, '\"')\r\n    .replace(/(&#96;)/g, '`')\r\n    .replace(/(&#x27;)/g, \"'\");\r\n};\r\n", "/// <reference types=\"@types/dompurify\" />\nimport { Debug } from '@finsweet/ts-utils';\n\nimport { DOMPURIFY_SRC } from '../utils/constants';\n\nlet DOMPurify: DOMPurify.DOMPurifyI | undefined;\n\n/**\n * Dynamically imports `DOMPurify` and memoizes the library.\n */\nconst importDOMPurify = async (): Promise<DOMPurify.DOMPurifyI | undefined> => {\n  if (DOMPurify) return DOMPurify;\n\n  try {\n    const module: { default: DOMPurify.DOMPurifyI } = await import(DOMPURIFY_SRC);\n\n    DOMPurify = module.default;\n\n    return DOMPurify;\n  } catch (error) {\n    Debug.alert('There was an issue while importing DOMPurify.', 'info');\n    return;\n  }\n};\n\n/**\n * Sanitizes an HTML string with `DOMPurify`.\n * @param rawHTML The HTML string to sanitize.\n */\nexport const sanitizeHTML = async (rawHTML: string): Promise<string> => {\n  const DOMPurify = await importDOMPurify();\n  if (!DOMPurify) return '';\n\n  return DOMPurify.sanitize(rawHTML);\n};\n", "import { HAS_COMPONENT_TEMPLATE_REGEX, IS_HTML_OPENING_TAG_REGEX } from '../utils/regex';\r\nimport type { TextElement } from '../utils/types';\r\nimport { getComponentHTML } from './components';\r\nimport { unescapeHTML } from './html';\r\nimport { sanitizeHTML } from './sanitize';\r\n\r\n/**\r\n * Parses the content of a text element and converts it to valid HTML.\r\n * @param textElement The {@link TextElement}.\r\n * @param sanitize Defines if the text content should be sanitized before parsing the HTML.\r\n */\r\nexport const parseTextElement = async (textElement: TextElement, sanitize: boolean) => {\r\n  const { innerHTML } = textElement;\r\n  const isComponent = HAS_COMPONENT_TEMPLATE_REGEX.test(innerHTML);\r\n\r\n  if (isComponent) {\r\n    const componentHTML = await getComponentHTML(innerHTML);\r\n    if (componentHTML) textElement.outerHTML = componentHTML;\r\n\r\n    return;\r\n  }\r\n\r\n  const isTag = textElement.tagName === 'P' && IS_HTML_OPENING_TAG_REGEX.test(innerHTML.trim());\r\n  const unescapedHTML = unescapeHTML(innerHTML);\r\n\r\n  textElement[isTag ? 'outerHTML' : 'innerHTML'] = sanitize ? await sanitizeHTML(unescapedHTML) : unescapedHTML;\r\n};\r\n", "import { restartWebflow, RICH_TEXT_BLOCK_CSS_CLASS } from '@finsweet/ts-utils';\nimport type { RichTextBlockElement } from '@finsweet/ts-utils';\n\nimport { getValidTextElements } from './actions/collect';\nimport { parseTextElement } from './actions/parse';\nimport { ATTRIBUTE, ATTRIBUTES, getSelector } from './utils/constants';\n\n// Constants\nconst {\n  sanitize: { key: sanitizeKey, values: sanitizeValues },\n  resetIx: { key: resetIxKey, values: resetIxValues },\n} = ATTRIBUTES;\n\n/**\n * Inits the attribute.\n */\nexport const init = async (): Promise<void> => {\n  const rtbElements = [\n    ...document.querySelectorAll<RichTextBlockElement>(\n      `.${RICH_TEXT_BLOCK_CSS_CLASS}${getSelector('element', 'richText', { operator: 'prefixed' })}`\n    ),\n  ];\n\n  await Promise.all(rtbElements.map(initRtbElement));\n\n  window.fsAttributes[ATTRIBUTE].resolve?.(rtbElements);\n};\n\n/**\n * Inits a Rich Text Block element, replacing HTML strings for their parsed version, and component templates for the component nodes.\n * @param element\n */\nconst initRtbElement = async (element: RichTextBlockElement) => {\n  const sanitize = element.getAttribute(sanitizeKey) === sanitizeValues.true;\n  const resetIx = element.getAttribute(resetIxKey) === resetIxValues.true;\n  const textElements = getValidTextElements(element);\n\n  await Promise.all(textElements.map((textElement) => parseTextElement(textElement, sanitize)));\n\n  if (resetIx) await restartWebflow(['ix2']);\n};\n", "import { assessScript } from '$global/factory/assess';\r\nimport { initAttributes } from '$global/factory/init';\r\n\r\nimport { init } from './init';\r\nimport { ATTRIBUTE } from './utils/constants';\r\n\r\n/**\r\n * Init\r\n */\r\ninitAttributes();\r\n\r\nconst { currentScript } = document;\r\nconst { preventsLoad } = assessScript(currentScript);\r\n\r\nif (preventsLoad) window.fsAttributes[ATTRIBUTE] = { init };\r\nelse {\r\n  window.Webflow ||= [];\r\n  window.Webflow.push(init);\r\n}\r\n"],
  "mappings": "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",
>>>>>>> Stashed changes
  "names": []
}
