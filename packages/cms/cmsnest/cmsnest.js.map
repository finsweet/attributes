{
  "version": 3,
  "sources": ["../../../node_modules/@finsweet/ts-utils/dist/components/Debug.js", "../../../node_modules/@finsweet/ts-utils/dist/webflow/css.js", "../../../node_modules/@finsweet/ts-utils/dist/helpers/cloneNode.js", "../../../node_modules/@finsweet/ts-utils/dist/webflow/getCollectionElements.js", "../../../node_modules/@finsweet/ts-utils/dist/webflow/getCollectionListWrappers.js", "../../../global/factory/selectors.ts", "../../../global/constants/attributes.ts", "../../../global/factory/assess.ts", "../../../global/factory/init.ts", "../../../global/import/cmscore.ts", "../utils/props.ts", "src/utils/constants.ts", "src/actions/collect.ts", "src/actions/populate.ts", "src/actions/events.ts", "src/factory.ts", "src/init.ts", "src/index.ts"],
  "sourcesContent": ["const alertTypes = ['info', 'error'];\r\nexport class Debug {\r\n    static alertsActivated = false;\r\n    static activateAlerts() {\r\n        this.alertsActivated = true;\r\n    }\r\n    static alert(text, type) {\r\n        if (this.alertsActivated)\r\n            window.alert(text);\r\n        if (type === 'error')\r\n            throw new Error(text);\r\n    }\r\n}\r\n", "export const CURRENT_CSS_CLASS = 'w--current';\r\nexport const RICH_TEXT_BLOCK_CSS_CLASS = 'w-richtext';\r\nexport const HTML_EMBED_CSS_CLASS = 'w-embed';\r\nexport const SLIDER_CSS_CLASSES = {\r\n    slider: 'w-slider',\r\n    slide: 'w-slide',\r\n    sliderMask: 'w-slider-mask',\r\n    sliderNav: 'w-slider-nav',\r\n    sliderDot: 'w-slider-dot',\r\n    activeSliderDot: 'w-active',\r\n};\r\nexport const TABS_CSS_CLASSES = {\r\n    tabs: 'w-tabs',\r\n    tabsContent: 'w-tab-content',\r\n    tabPane: 'w-tab-pane',\r\n    tabsMenu: 'w-tab-menu',\r\n    tabLink: 'w-tab-link',\r\n    activeTab: 'w--tab-active',\r\n};\r\nexport const NAVBAR_CSS_CLASSES = {\r\n    navMenu: 'w-nav-menu',\r\n};\r\nexport const CMS_CSS_CLASSES = {\r\n    wrapper: 'w-dyn-list',\r\n    list: 'w-dyn-items',\r\n    item: 'w-dyn-item',\r\n    paginationWrapper: 'w-pagination-wrapper',\r\n    paginationNext: 'w-pagination-next',\r\n    paginationPrevious: 'w-pagination-previous',\r\n    pageCount: 'w-page-count',\r\n    emptyState: 'w-dyn-empty',\r\n};\r\nexport const FORM_CSS_CLASSES = {\r\n    formBlock: 'w-form',\r\n    checkboxField: 'w-checkbox',\r\n    checkboxInput: 'w-checkbox-input',\r\n    radioField: 'w-radio',\r\n    radioInput: 'w-radio-input',\r\n    checkboxOrRadioLabel: 'w-form-label',\r\n    checkboxOrRadioFocus: 'w--redirected-focus',\r\n    checkboxOrRadioChecked: 'w--redirected-checked',\r\n    successMessage: 'w-form-done',\r\n    errorMessage: 'w-form-fail',\r\n};\r\nexport const DROPDOWN_CSS_CLASSES = {\r\n    dropdown: 'w-dropdown',\r\n    dropdownToggle: 'w-dropdown-toggle',\r\n    dropdownList: 'w-dropdown-list',\r\n};\r\nexport const COMMERCE_CSS_CLASSES = {\r\n    addToCartForm: 'w-commerce-commerceaddtocartform',\r\n};\r\nexport const LIGHTBOX_CSS_CLASSES = {\r\n    trigger: 'w-lightbox',\r\n};\r\n", "export const cloneNode = (node, deep = true) => node.cloneNode(deep);\r\n", "import { CMS_CSS_CLASSES } from '.';\r\nconst { wrapper, list, paginationWrapper, paginationNext, paginationPrevious, emptyState, pageCount } = CMS_CSS_CLASSES;\r\nexport function getCollectionElements(reference, target, page = document) {\r\n    const referenceElement = typeof reference === 'string' ? page.querySelector(reference) : reference;\r\n    if (!referenceElement)\r\n        return;\r\n    const collectionListWrapper = referenceElement.closest(`.${wrapper}`);\r\n    if (!collectionListWrapper)\r\n        return;\r\n    const collectionList = collectionListWrapper.querySelector(`.${list}`);\r\n    if (target === 'wrapper')\r\n        return collectionListWrapper;\r\n    if (target === 'list')\r\n        return collectionList;\r\n    if (target === 'items')\r\n        return [...(collectionList?.children || [])];\r\n    if (target === 'pageCount')\r\n        return collectionListWrapper.querySelector(`.${pageCount}`);\r\n    if (target === 'empty') {\r\n        return collectionListWrapper.querySelector(`:scope > .${emptyState}`);\r\n    }\r\n    if (target === 'pagination') {\r\n        return collectionListWrapper.querySelector(`.${paginationWrapper}`);\r\n    }\r\n    return collectionListWrapper.querySelector(`.${target === 'next' ? paginationNext : paginationPrevious}`);\r\n}\r\n", "import { CMS_CSS_CLASSES, getCollectionElements } from '.';\r\nexport const getCollectionListWrappers = (selectors, page = document) => {\r\n    selectors = selectors.filter((selector) => selector);\r\n    const selector = selectors.join(', ') || `.${CMS_CSS_CLASSES.wrapper}`;\r\n    const referenceElements = [...page.querySelectorAll(selector)];\r\n    const collectionListWrappers = referenceElements.reduce((wrappers, referenceElement) => {\r\n        if (!referenceElement)\r\n            return wrappers;\r\n        const collectionListWrapper = getCollectionElements(referenceElement, 'wrapper');\r\n        if (!collectionListWrapper || wrappers.includes(collectionListWrapper))\r\n            return wrappers;\r\n        wrappers.push(collectionListWrapper);\r\n        return wrappers;\r\n    }, []);\r\n    return collectionListWrappers;\r\n};\r\n", "import type { AttributeOperator, AttributeStaticValue, AttributeValue } from '$global/types/selectors';\n\n/**\n * Creates a dynamic attribute value.\n * @param value The static attribute value.\n * @returns A callback for generating new attribute values by index.\n */\nexport const generateDynamicAttibuteValue = (value: string) => {\n  return (index?: number): string => `${value}${index ? `-${index}` : ''}`;\n};\n\n/**\n * @returns A `getSelector` callback for the passed `attributes` object.\n * @param attributes An object containing all attribute keys and values.\n */\nexport const generateSelectors = <\n  Attributes extends {\n    [name: string]: {\n      key: string;\n      values?: {\n        [valueKey: string]: AttributeValue;\n      };\n    };\n  }\n>(\n  attributes: Attributes\n) => {\n  /**\n   * Generates a query selector based on the preferences.\n   * @param name The name of the attribute.\n   * @param valueKey The value of the attribute.\n   * @param params.index Only accepted when the value is dynamic.\n   * @param params.operator Optional operator for the selector.\n   * @returns The query selector based on the preferences.\n   */\n  const getSelector = <Name extends keyof Attributes, ValueKey extends keyof Attributes[Name]['values']>(\n    name: Name,\n    valueKey?: ValueKey,\n    params?: Attributes[Name]['values'][ValueKey] extends AttributeStaticValue\n      ? {\n          operator?: AttributeOperator;\n        }\n      : {\n          instanceIndex?: number;\n          operator?: AttributeOperator;\n        }\n  ): string => {\n    const attribute = attributes[name];\n\n    const { key: attributeKey, values } = attribute;\n    let attributeValue: string;\n\n    if (!valueKey) return `[${attributeKey}]`;\n\n    const value = values?.[valueKey] as AttributeValue;\n\n    if (typeof value === 'string') attributeValue = value;\n    else attributeValue = value(params && 'instanceIndex' in params ? params.instanceIndex : undefined);\n\n    if (!params?.operator) return `[${attributeKey}=\"${attributeValue}\"]`;\n\n    switch (params.operator) {\n      case 'prefixed':\n        return `[${attributeKey}^=\"${attributeValue}\"]`;\n      case 'suffixed':\n        return `[${attributeKey}$=\"${attributeValue}\"]`;\n      case 'contains':\n        return `[${attributeKey}*=\"${attributeValue}\"]`;\n    }\n  };\n\n  /**\n   * Queries an element using the generated element selectors.\n   * @param elementKey The element key.\n   * @param params.index Only accepted when the value is dynamic.\n   * @param params.operator Optional operator for the selector.\n   * @param params.scope The scope for the query. Defaults to `document`.\n   */\n  const queryElement = <\n    E extends Element = Element,\n    ElementKey extends keyof Attributes['element']['values'] = keyof Attributes['element']['values']\n  >(\n    elementKey: ElementKey,\n    params?: { scope?: ParentNode } & (Attributes['element']['values'][ElementKey] extends AttributeStaticValue\n      ? {\n          operator?: AttributeOperator;\n        }\n      : {\n          instanceIndex?: number;\n          operator?: AttributeOperator;\n        })\n  ) => {\n    const selector = getSelector('element', elementKey, params);\n\n    return (params?.scope || document).querySelector<E>(selector);\n  };\n\n  return [getSelector, queryElement] as const;\n};\n", "import { generateSelectors } from '$global/factory/selectors';\r\n\r\n/**\r\n * Constants\r\n */\r\nexport const ATTRIBUTES_PREFIX = 'fs-attributes';\r\n\r\nexport const ATTRIBUTES = {\r\n  /**\r\n   * Defines if an Attributes' `<script>` should prevent automatically loading the library.\r\n   */\r\n  preventLoad: { key: `${ATTRIBUTES_PREFIX}-preventload` },\r\n\r\n  /**\r\n   * Defines if an Attributes' `<script>` is set to Debug Mode.\r\n   */\r\n  debugMode: { key: `${ATTRIBUTES_PREFIX}-debug` },\r\n\r\n  /**\r\n   * Defines the source of an attribute script.\r\n   */\r\n  src: { key: 'src', values: { finsweet: '@finsweet/attributes' } },\r\n\r\n  /**\r\n   * Defines a developer script that is not imported from JsDelivr.\r\n   */\r\n  dev: { key: `${ATTRIBUTES_PREFIX}-dev` },\r\n} as const;\r\n\r\nexport const [getSelector, queryElement] = generateSelectors(ATTRIBUTES);\r\n", "import { Debug } from '@finsweet/ts-utils';\r\n\r\nimport { ATTRIBUTES } from '../constants/attributes';\r\nimport { GlobalAttributeParams } from '../types/global';\r\n\r\n/**\r\n * Checks the global params of the Attribute `<script>`.\r\n * @param script The `<script>` element.\r\n * @returns The {@link GlobalAttributeParams}.\r\n */\r\n\r\nexport const assessScript = (): GlobalAttributeParams => {\r\n  const { currentScript } = document;\r\n  const { preventLoad, debugMode } = ATTRIBUTES;\r\n\r\n  // Check if the Attribute should not be automatically loaded\r\n  const preventsLoad = typeof currentScript?.getAttribute(preventLoad.key) === 'string';\r\n\r\n  // Check if Debug Mode is activated\r\n  if (typeof currentScript?.getAttribute(debugMode.key) === 'string') Debug.activateAlerts();\r\n\r\n  return { preventsLoad };\r\n};\r\n", "import { ATTRIBUTES, getSelector } from '$global/constants/attributes';\r\nimport type { FsAttributes, FsAttributesCallback } from '$global/types/global';\r\n\r\n/**\r\n * Makes sure the window object is defined.\r\n */\r\nexport const initAttributes = () => {\r\n  if (window.fsAttributes && !Array.isArray(window.fsAttributes)) return;\r\n\r\n  const fsAttributes = {\r\n    cms: {},\r\n    push(...args) {\r\n      for (const [attributeName, callback] of args) this[attributeName]?.loading?.then(callback);\r\n    },\r\n  } as FsAttributes;\r\n\r\n  initLoadPromises(fsAttributes);\r\n  runExistingCallbacks(fsAttributes);\r\n\r\n  window.fsAttributes = fsAttributes;\r\n  window.FsAttributes = window.fsAttributes;\r\n};\r\n\r\n/**\r\n * Sets a loading promise for each attribute package.\r\n * @param fsAttributes The {@link FsAttributes} object.\r\n */\r\nconst initLoadPromises = (fsAttributes: FsAttributes) => {\r\n  const srcSelector = getSelector('src', 'finsweet', { operator: 'contains' });\r\n  const devSelector = getSelector('dev');\r\n  const scripts = [...document.querySelectorAll<HTMLScriptElement>(`script${srcSelector}, script${devSelector}`)];\r\n\r\n  const attributes = scripts.reduce<string[]>((acc, script) => {\r\n    const attributeName = script.getAttribute(ATTRIBUTES.dev.key) || script.src.match(/[\\w-. ]+(?=(\\.js)$)/)?.[0];\r\n    if (attributeName && !acc.includes(attributeName)) acc.push(attributeName);\r\n\r\n    return acc;\r\n  }, []);\r\n\r\n  for (const attributeName of attributes) {\r\n    fsAttributes[attributeName] = {};\r\n    const attribute = fsAttributes[attributeName];\r\n\r\n    attribute.loading = new Promise((resolve) => {\r\n      attribute.resolve = (value: unknown) => {\r\n        resolve(value);\r\n        delete attribute.resolve;\r\n      };\r\n    });\r\n  }\r\n};\r\n\r\n/**\r\n * Runs the existing callbacks in the `window.fsAttributes` object.\r\n * @param fsAttributes The {@link FsAttributes} object.\r\n */\r\nconst runExistingCallbacks = (fsAttributes: FsAttributes) => {\r\n  const existingCallbacks = Array.isArray(window.fsAttributes) ? (window.fsAttributes as FsAttributesCallback[]) : [];\r\n  fsAttributes.push(...existingCallbacks);\r\n};\r\n", "import { Debug } from '@finsweet/ts-utils';\r\n\r\nimport type { CMSCoreImport } from '$cms/cmscore/src/types';\r\n\r\nconst CMS_CORE_SOURCE = 'https://cdn.jsdelivr.net/npm/@finsweet/attributes-cmscore@1/cmscore.js';\r\n// const CMS_CORE_SOURCE = 'http://localhost:3000/packages/cms/cmscore/cmscore.js';\r\n\r\n/**\r\n * Dynamically imports the `cms/cmscore` package.\r\n * After the first import, it stores the response in {@link window.fsAttributes.cms.coreImport}.\r\n *\r\n * Once the import has finished, it also stores the `cmscore` version so other `cms` packages can access it.\r\n *\r\n * @returns A `Promise` of the package response.\r\n */\r\nexport const importCMSCore = async (): CMSCoreImport => {\r\n  const { fsAttributes } = window;\r\n\r\n  fsAttributes.cms ||= {};\r\n  const { cms } = fsAttributes;\r\n\r\n  if (cms.coreImport) return cms.coreImport;\r\n\r\n  try {\r\n    const cmsCoreImport: CMSCoreImport = import(CMS_CORE_SOURCE);\r\n\r\n    cms.coreImport = cmsCoreImport;\r\n\r\n    cmsCoreImport.then((cmsCore) => {\r\n      if (cmsCore) cms.coreVersion ||= cmsCore.version;\r\n    });\r\n\r\n    return cmsCoreImport;\r\n  } catch (error) {\r\n    Debug.alert(`${error}`, 'error');\r\n    return;\r\n  }\r\n};\r\n", "/**\n * Normalizes a property key.\n * - Trims the string.\n * - Lowercases the string.\n *\n * @param propKey The property key to normalize.\n */\nexport function normalizePropKey(propKey: string): string;\nexport function normalizePropKey(propKey?: string | null): string | undefined;\nexport function normalizePropKey(propKey?: string | null): string | undefined {\n  return propKey?.trim().toLowerCase();\n}\n", "import { generateSelectors } from '$global/factory/selectors';\r\n\r\nexport const ATTRIBUTE = 'cmsnest';\r\n\r\nconst ATTRIBUTES_PREFIX = `fs-${ATTRIBUTE}`;\r\n\r\nexport const LIST_ELEMENT_KEY = 'list';\r\nexport const COLLECTION_SETTING_KEY = 'collection';\r\nexport const EMPTY_SETTING_KEY = 'empty';\r\n\r\nexport const ATTRIBUTES = {\r\n  element: {\r\n    key: `${ATTRIBUTES_PREFIX}-element`,\r\n    values: {\r\n      /**\r\n       * Defines a list to be combined into the target.\r\n       */\r\n      list: LIST_ELEMENT_KEY,\r\n    },\r\n  },\r\n\r\n  /**\r\n   * Defines a Collection List that will be nested inside the target list element.\r\n   */\r\n  collection: { key: `${ATTRIBUTES_PREFIX}-${COLLECTION_SETTING_KEY}` },\r\n\r\n  /**\r\n   * Defines an `Empty State` element.\r\n   */\r\n  empty: { key: `${ATTRIBUTES_PREFIX}-${EMPTY_SETTING_KEY}` },\r\n} as const;\r\n\r\nexport const [getSelector, queryElement] = generateSelectors(ATTRIBUTES);\r\n", "import type { CollectionItemElement } from '@finsweet/ts-utils';\r\n\r\nimport type { CMSCore } from '$cms/cmscore/src/types';\r\nimport { normalizePropKey } from '$cms/utils/props';\r\n\r\nimport { ATTRIBUTES, getSelector } from '../utils/constants';\r\nimport type { NestSources, NestTargets } from '../utils/types';\r\n\r\n// Constants\r\nconst {\r\n  collection: { key: collectionKey },\r\n  empty: { key: emptyKey },\r\n} = ATTRIBUTES;\r\n\r\n/**\r\n * Queries the existing CMS Collections on the page that will be nested inside the main list instance.\r\n * @returns A `Map` with the `collectionKey` as the keys and `CMSList` instances as the values.\r\n */\r\nexport const getNestSources = ({ createCMSListInstances }: CMSCore): NestSources => {\r\n  const nestSources: NestSources = new Map();\r\n\r\n  const listInstances = createCMSListInstances([getSelector('collection')]);\r\n\r\n  for (const listInstance of listInstances) {\r\n    const collectionId = normalizePropKey(listInstance.getAttribute(collectionKey));\r\n    if (!collectionId) continue;\r\n\r\n    const emptyElement = document.querySelector<HTMLElement>(`[${emptyKey}^=\"${collectionId}\"]`);\r\n    if (emptyElement) emptyElement.style.display = 'none';\r\n    listInstance.wrapper.style.display = 'none';\r\n\r\n    nestSources.set(collectionId, { listInstance, emptyElement });\r\n  }\r\n\r\n  return nestSources;\r\n};\r\n\r\n/**\r\n * Queries the target elements where the nested CMS Collections will be appended.\r\n * @param itemElement The `CollectionItemElement`.\r\n * @returns A `Map` with the `collectionKey` as the keys and `HTMLElement` targets as the values.\r\n */\r\nexport const getNestTargets = (itemElement: CollectionItemElement) => {\r\n  const nestTargets: NestTargets = new Map();\r\n  const nestTargetElements = itemElement.querySelectorAll<HTMLElement>(getSelector('collection'));\r\n\r\n  for (const target of nestTargetElements) {\r\n    const collectionId = normalizePropKey(target.getAttribute(collectionKey));\r\n    if (!collectionId) continue;\r\n\r\n    nestTargets.set(collectionId, target);\r\n  }\r\n\r\n  return nestTargets;\r\n};\r\n", "import { cloneNode, getCollectionElements, getCollectionListWrappers } from '@finsweet/ts-utils';\r\nimport type { CollectionItemElement } from '@finsweet/ts-utils';\r\n\r\nimport type { CMSItem } from '$cms/cmscore/src';\r\nimport type { CMSCore } from '$cms/cmscore/src/types';\r\nimport { normalizePropKey } from '$cms/utils/props';\r\n\r\nimport { ATTRIBUTES, getSelector } from '../utils/constants';\r\nimport type { NestSources } from '../utils/types';\r\nimport { getNestTargets } from './collect';\r\n\r\n// Constants\r\nconst domParser = new DOMParser();\r\n\r\n/**\r\n * Fetches each Collection Item's Template Page, checks which nested items belong to it, and appends the nested collection only containing the correspondent items.\r\n * @param cmsItem A `CMSItem` instance.\r\n * @param nestSources The {@link NestSources} object.\r\n */\r\nexport const populateNestedCollections = async (\r\n  { element, href }: CMSItem,\r\n  nestSources: NestSources,\r\n  { CMSList }: CMSCore\r\n): Promise<void> => {\r\n  if (!href) return;\r\n\r\n  // Get the nest targets\r\n  const nestTargets = getNestTargets(element);\r\n  if (!nestTargets.size) return;\r\n\r\n  // Fetch the `Collection Item`'s Template Page\r\n  const response = await fetch(href);\r\n  const rawPage = await response.text();\r\n  const page = domParser.parseFromString(rawPage, 'text/html');\r\n\r\n  // Get the existing lists to nest\r\n  const pageCollectionListWrappers = getCollectionListWrappers([getSelector('collection')], page);\r\n\r\n  // Populate the nested CMS lists only with the correspondent nested items\r\n  pageCollectionListWrappers.forEach((pageCollectionListWrapper, index) => {\r\n    const pageListInstance = new CMSList(pageCollectionListWrapper, index);\r\n\r\n    const collectionId = normalizePropKey(pageListInstance.getAttribute(ATTRIBUTES.collection.key));\r\n    if (!collectionId) return;\r\n\r\n    const nestSource = nestSources.get(collectionId);\r\n    const nestTarget = nestTargets.get(collectionId);\r\n    if (!nestSource || !nestTarget) return;\r\n\r\n    const nestTargetParent = nestTarget.parentElement;\r\n    if (!nestTargetParent) return;\r\n\r\n    const { listInstance, emptyElement } = nestSource;\r\n\r\n    const itemsToNest = pageListInstance.items.reduce<CollectionItemElement[]>((items, { href }) => {\r\n      if (!href) return items;\r\n\r\n      const matchingItem = listInstance.items.find((item) => item.href && href === item.href);\r\n      if (!matchingItem) return items;\r\n\r\n      items.push(matchingItem.element);\r\n      return items;\r\n    }, []);\r\n\r\n    if (!itemsToNest.length && !emptyElement) return;\r\n\r\n    const newCollectionWrapper = cloneNode(listInstance.wrapper);\r\n    const newCollectionItems = getCollectionElements(newCollectionWrapper, 'items');\r\n    newCollectionWrapper.style.display = '';\r\n\r\n    if (itemsToNest.length) {\r\n      for (const newCollectionItem of newCollectionItems) {\r\n        const shouldBeNested = !!itemsToNest.find((itemToNest) => itemToNest.isEqualNode(newCollectionItem));\r\n\r\n        if (!shouldBeNested) newCollectionItem.remove();\r\n      }\r\n    } else if (emptyElement) {\r\n      const newCollectionList = getCollectionElements(newCollectionWrapper, 'list');\r\n      newCollectionList?.remove();\r\n\r\n      const newEmptyElement = cloneNode(emptyElement);\r\n      newEmptyElement.style.display = '';\r\n\r\n      newCollectionWrapper.appendChild(newEmptyElement);\r\n    }\r\n\r\n    nestTargetParent.insertBefore(newCollectionWrapper, nestTarget);\r\n    nestTarget.remove();\r\n  });\r\n};\r\n", "import type { CMSList } from '$cms/cmscore/src';\r\nimport type { CMSCore } from '$cms/cmscore/src/types';\r\n\r\nimport type { NestSources } from '../utils/types';\r\nimport { populateNestedCollections } from './populate';\r\n\r\n/**\r\n * Listen for events emitted from the `CMSList` instances.\r\n * @param listInstance A {@link CMSList} instance.\r\n * @param nestSources The stored {@link NestSources}.\r\n * @param cmsCore The {@link CMSCore} import.\r\n */\r\nexport const listenListEvents = (listInstance: CMSList, nestSources: NestSources, cmsCore: CMSCore) => {\r\n  listInstance.on('shouldnest', async (newItems) => {\r\n    await Promise.all(newItems.map((newItem) => populateNestedCollections(newItem, nestSources, cmsCore)));\r\n  });\r\n};\r\n", "import { Debug } from '@finsweet/ts-utils';\r\n\r\nimport { CMSList } from '$cms/cmscore/src';\r\nimport { CMSCore } from '$cms/cmscore/src/types';\r\n\r\nimport { getNestSources } from './actions/collect';\r\nimport { listenListEvents } from './actions/events';\r\nimport { populateNestedCollections } from './actions/populate';\r\n\r\n/**\r\n * Inits the nesting.\r\n * @param listInstance A {@link CMSList} instance.\r\n * @param cmsCore The {@link CMSCore} import.\r\n */\r\nexport const initListNesting = async (listInstance: CMSList, cmsCore: CMSCore): Promise<void> => {\r\n  // Collect the collections to nest\r\n  const nestSources = getNestSources(cmsCore);\r\n  if (!nestSources.size) {\r\n    Debug.alert(`No collections to nest found for the list n\u00BA ${listInstance.index}`, 'info');\r\n    return;\r\n  }\r\n\r\n  // Listen for events\r\n  listenListEvents(listInstance, nestSources, cmsCore);\r\n\r\n  // Nest existing items\r\n  const existingItems = [...listInstance.items];\r\n\r\n  await Promise.all(existingItems.map((item) => populateNestedCollections(item, nestSources, cmsCore)));\r\n  await listInstance.emitSerial('nestinitialitems', existingItems);\r\n};\r\n", "import type { CMSList } from '$cms/cmscore/src';\r\nimport { importCMSCore } from '$global/import/cmscore';\r\n\r\nimport { initListNesting } from './factory';\r\nimport { ATTRIBUTE, getSelector } from './utils/constants';\r\n\r\n/**\r\n * Inits the attribute.\r\n */\r\nexport const init = async (): Promise<CMSList[]> => {\r\n  const cmsCore = await importCMSCore();\r\n  if (!cmsCore) return [];\r\n\r\n  // Create the list instances\r\n  const listInstances = cmsCore.createCMSListInstances([getSelector('element', 'list', { operator: 'prefixed' })]);\r\n\r\n  await Promise.all(listInstances.map((listInstance) => initListNesting(listInstance, cmsCore)));\r\n\r\n  window.fsAttributes[ATTRIBUTE].resolve?.(listInstances);\r\n\r\n  return listInstances;\r\n};\r\n", "import { assessScript } from '$global/factory/assess';\r\nimport { initAttributes } from '$global/factory/init';\r\nimport { importCMSCore } from '$global/import/cmscore';\r\n\r\nimport { version } from '../package.json';\r\nimport { init } from './init';\r\nimport { ATTRIBUTE } from './utils/constants';\r\n\r\n/**\r\n * Init\r\n */\r\ninitAttributes();\r\nimportCMSCore();\r\n\r\nwindow.fsAttributes[ATTRIBUTE] ||= {};\r\n\r\nconst { preventsLoad } = assessScript();\r\nconst attribute = window.fsAttributes[ATTRIBUTE];\r\n\r\nattribute.version = version;\r\n\r\nif (preventsLoad) attribute.init = init;\r\nelse {\r\n  window.Webflow ||= [];\r\n  window.Webflow.push(init);\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
