{
  "version": 3,
  "sources": ["../../node_modules/just-debounce/index.js", "../../node_modules/@finsweet/ts-utils/dist/components/Debug.js", "../../node_modules/@finsweet/ts-utils/dist/helpers/simulateEvent.js", "../../node_modules/@finsweet/ts-utils/dist/helpers/getHiddenParent.js", "../../node_modules/@finsweet/ts-utils/dist/helpers/isVisible.js", "../../node_modules/@finsweet/ts-utils/dist/helpers/setFormFieldValue.js", "../../node_modules/@finsweet/ts-utils/dist/type-guards/isFormField.js", "../../node_modules/@finsweet/ts-utils/dist/type-guards/isNotEmpty.js", "../../global/factory/selectors.ts", "../../global/constants/attributes.ts", "../../global/factory/assess.ts", "../../global/factory/init.ts", "src/init.ts", "src/actions/events.ts", "../../global/constants/keyboard.ts", "src/utils/constants.ts", "src/actions/values.ts", "src/actions/settings.ts", "src/components/Fill.ts", "../../global/constants/a11ty.ts", "src/actions/a11ty.ts", "src/actions/styles.ts", "src/components/Handle.ts", "src/factory.ts", "src/index.ts"],
  "sourcesContent": ["module.exports = debounce;\n\nfunction debounce(fn, delay, atStart, guarantee) {\n  var timeout;\n  var args;\n  var self;\n\n  return function debounced() {\n    self = this;\n    args = Array.prototype.slice.call(arguments);\n\n    if (timeout && (atStart || guarantee)) {\n      return;\n    } else if (!atStart) {\n      clear();\n\n      timeout = setTimeout(run, delay);\n      return timeout;\n    }\n\n    timeout = setTimeout(clear, delay);\n    fn.apply(self, args);\n\n    function run() {\n      clear();\n      fn.apply(self, args);\n    }\n\n    function clear() {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n}\n", "const alertTypes = ['info', 'error'];\r\nexport class Debug {\r\n    static alertsActivated = false;\r\n    static activateAlerts() {\r\n        this.alertsActivated = true;\r\n    }\r\n    static alert(text, type) {\r\n        if (this.alertsActivated)\r\n            window.alert(text);\r\n        if (type === 'error')\r\n            throw new Error(text);\r\n    }\r\n}\r\n", "export const simulateEvent = (target, events) => {\r\n    if (!Array.isArray(events))\r\n        events = [events];\r\n    const eventsSuccess = events.map((event) => target.dispatchEvent(new Event(event, { bubbles: true })));\r\n    return eventsSuccess.every((success) => success);\r\n};\r\n", "import { isVisible } from '.';\r\nexport const getHiddenParent = (element) => {\r\n    if (isVisible(element))\r\n        return;\r\n    let previousElement = element;\r\n    const checkParent = ({ parentElement }) => {\r\n        if (!parentElement)\r\n            return;\r\n        if (isVisible(parentElement))\r\n            return;\r\n        previousElement = parentElement;\r\n        checkParent(parentElement);\r\n    };\r\n    checkParent(element);\r\n    return previousElement;\r\n};\r\n", "export const isVisible = (element) => !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);\r\n", "import { simulateEvent } from '.';\r\nexport const setFormFieldValue = (element, value) => {\r\n    const { type } = element;\r\n    if (typeof value === 'boolean') {\r\n        if (!(element instanceof HTMLInputElement) ||\r\n            (type !== 'radio' && type !== 'checkbox') ||\r\n            (type === 'checkbox' && value === false) ||\r\n            value === element.checked)\r\n            return;\r\n        element.checked = value;\r\n    }\r\n    else {\r\n        if (type === 'radio' || type === 'checkbox' || element.value === value)\r\n            return;\r\n        element.value = value;\r\n    }\r\n    simulateEvent(element, ['click', 'input', 'change']);\r\n};\r\n", "export const isFormField = (element) => element instanceof HTMLInputElement || element instanceof HTMLSelectElement || element instanceof HTMLTextAreaElement;\r\n", "export const isNotEmpty = (value) => value !== undefined && value !== null;\r\n", "import type { AttributeOperator, AttributeStaticValue, AttributeValue } from '$global/types/selectors';\n\n/**\n * Creates a dynamic attribute value.\n * @param value The static attribute value.\n * @returns A callback for generating new attribute values by index.\n */\nexport const generateDynamicAttibuteValue = (value: string) => {\n  return (index?: number): string => `${value}${index ? `-${index}` : ''}`;\n};\n\n/**\n * @returns A `getSelector` callback for the passed `attributes` object.\n * @param attributes An object containing all attribute keys and values.\n */\nexport const generateSelectors = <\n  Attributes extends {\n    [name: string]: {\n      key: string;\n      values?: {\n        [valueKey: string]: AttributeValue;\n      };\n    };\n  }\n>(\n  attributes: Attributes\n) => {\n  /**\n   * Generates a query selector based on the preferences.\n   * @param name The name of the attribute.\n   * @param valueKey The value of the attribute.\n   * @param params.index Only accepted when the value is dynamic.\n   * @param params.operator Optional operator for the selector.\n   * @returns The query selector based on the preferences.\n   */\n  const getSelector = <Name extends keyof Attributes, ValueKey extends keyof Attributes[Name]['values']>(\n    name: Name,\n    valueKey?: ValueKey,\n    params?: Attributes[Name]['values'][ValueKey] extends AttributeStaticValue\n      ? {\n          operator?: AttributeOperator;\n        }\n      : {\n          instanceIndex?: number;\n          operator?: AttributeOperator;\n        }\n  ): string => {\n    const attribute = attributes[name];\n\n    const { key: attributeKey, values } = attribute;\n    let attributeValue: string;\n\n    if (!valueKey) return `[${attributeKey}]`;\n\n    const value = values?.[valueKey] as AttributeValue;\n\n    if (typeof value === 'string') attributeValue = value;\n    else attributeValue = value(params && 'instanceIndex' in params ? params.instanceIndex : undefined);\n\n    if (!params?.operator) return `[${attributeKey}=\"${attributeValue}\"]`;\n\n    switch (params.operator) {\n      case 'prefixed':\n        return `[${attributeKey}^=\"${attributeValue}\"]`;\n      case 'suffixed':\n        return `[${attributeKey}$=\"${attributeValue}\"]`;\n      case 'contains':\n        return `[${attributeKey}*=\"${attributeValue}\"]`;\n    }\n  };\n\n  /**\n   * Queries an element using the generated element selectors.\n   * @param elementKey The element key.\n   * @param params.index Only accepted when the value is dynamic.\n   * @param params.operator Optional operator for the selector.\n   * @param params.scope The scope for the query. Defaults to `document`.\n   */\n  const queryElement = <\n    E extends Element = Element,\n    ElementKey extends keyof Attributes['element']['values'] = keyof Attributes['element']['values']\n  >(\n    elementKey: ElementKey,\n    params?: { scope?: ParentNode } & (Attributes['element']['values'][ElementKey] extends AttributeStaticValue\n      ? {\n          operator?: AttributeOperator;\n        }\n      : {\n          instanceIndex?: number;\n          operator?: AttributeOperator;\n        })\n  ) => {\n    const selector = getSelector('element', elementKey, params);\n\n    return (params?.scope || document).querySelector<E>(selector);\n  };\n\n  return [getSelector, queryElement] as const;\n};\n", "import { generateSelectors } from '$global/factory/selectors';\n\n/**\n * Constants\n */\nexport const ATTRIBUTES_PREFIX = 'fs-attributes';\n\nexport const ATTRIBUTES = {\n  /**\n   * Defines if an Attributes' `<script>` should prevent automatically loading the library.\n   */\n  preventLoad: { key: `${ATTRIBUTES_PREFIX}-preventload` },\n\n  /**\n   * Defines if an Attributes' `<script>` is set to Debug Mode.\n   */\n  debugMode: { key: `${ATTRIBUTES_PREFIX}-debug` },\n\n  /**\n   * Defines the source of an attribute script.\n   */\n  src: { key: 'src', values: { finsweet: '@finsweet/attributes' } },\n\n  /**\n   * Defines a developer script that is not imported from JsDelivr.\n   */\n  dev: { key: `${ATTRIBUTES_PREFIX}-dev` },\n} as const;\n\nexport const [getSelector, queryElement] = generateSelectors(ATTRIBUTES);\n", "import { Debug } from '@finsweet/ts-utils';\n\nimport { ATTRIBUTES } from '../constants/attributes';\nimport { GlobalAttributeParams } from '../types/global';\n\n/**\n * Checks the global params of the Attribute `<script>`.\n * @param script The `<script>` element.\n * @returns The {@link GlobalAttributeParams}.\n */\n\nexport const assessScript = (): GlobalAttributeParams => {\n  const { currentScript } = document;\n  const { preventLoad, debugMode } = ATTRIBUTES;\n\n  // Check if the Attribute should not be automatically loaded\n  const preventsLoad = typeof currentScript?.getAttribute(preventLoad.key) === 'string';\n\n  // Check if Debug Mode is activated\n  if (typeof currentScript?.getAttribute(debugMode.key) === 'string') Debug.activateAlerts();\n\n  return { preventsLoad };\n};\n", "import { ATTRIBUTES, getSelector } from '$global/constants/attributes';\r\nimport type { FsAttributes, FsAttributesCallback } from '$global/types/global';\r\n\r\n/**\r\n * Makes sure the window object is defined.\r\n */\r\nexport const initAttributes = () => {\r\n  if (window.fsAttributes && !Array.isArray(window.fsAttributes)) return;\r\n\r\n  const fsAttributes = {\r\n    cms: {},\r\n    push(...args) {\r\n      for (const [attributeName, callback] of args) this[attributeName]?.loading?.then(callback);\r\n    },\r\n  } as FsAttributes;\r\n\r\n  initLoadPromises(fsAttributes);\r\n  runExistingCallbacks(fsAttributes);\r\n\r\n  window.fsAttributes = fsAttributes;\r\n  window.FsAttributes = window.fsAttributes;\r\n};\r\n\r\n/**\r\n * Sets a loading promise for each attribute package.\r\n * @param fsAttributes The {@link FsAttributes} object.\r\n */\r\nconst initLoadPromises = (fsAttributes: FsAttributes) => {\r\n  const srcSelector = getSelector('src', 'finsweet', { operator: 'contains' });\r\n  const devSelector = getSelector('dev');\r\n  const scripts = [...document.querySelectorAll<HTMLScriptElement>(`script${srcSelector}, script${devSelector}`)];\r\n\r\n  const attributes = scripts.reduce<string[]>((acc, script) => {\r\n    const attributeName = script.getAttribute(ATTRIBUTES.dev.key) || script.src.match(/[\\w-. ]+(?=(\\.js)$)/)?.[0];\r\n    if (attributeName && !acc.includes(attributeName)) acc.push(attributeName);\r\n\r\n    return acc;\r\n  }, []);\r\n\r\n  for (const attributeName of attributes) {\r\n    fsAttributes[attributeName] = {};\r\n    const attribute = fsAttributes[attributeName];\r\n\r\n    attribute.loading = new Promise((resolve) => {\r\n      attribute.resolve = (value: unknown) => {\r\n        resolve(value);\r\n        delete attribute.resolve;\r\n      };\r\n    });\r\n  }\r\n};\r\n\r\n/**\r\n * Runs the existing callbacks in the `window.fsAttributes` object.\r\n * @param fsAttributes The {@link FsAttributes} object.\r\n */\r\nconst runExistingCallbacks = (fsAttributes: FsAttributes) => {\r\n  const existingCallbacks = Array.isArray(window.fsAttributes) ? (window.fsAttributes as FsAttributesCallback[]) : [];\r\n  fsAttributes.push(...existingCallbacks);\r\n};\r\n", "import { getHiddenParent, isNotEmpty, isVisible } from '@finsweet/ts-utils';\nimport debounce from 'just-debounce';\n\nimport { getClientX } from './actions/events';\nimport { getSettings } from './actions/settings';\nimport { adjustValueToStep, getClosestValidHandle } from './actions/values';\nimport type { Handle } from './components/Handle';\nimport { createFillInstance, createHandleInstances } from './factory';\nimport { ATTRIBUTE, getSelector } from './utils/constants';\nimport type { HandleInstances } from './utils/types';\n\n/**\n * Inits the attribute.\n */\nexport const init = (): HandleInstances[] => {\n  const wrapperElements = [\n    ...document.querySelectorAll<HTMLElement>(getSelector('element', 'wrapper', { operator: 'prefixed' })),\n  ];\n\n  const handleInstances = wrapperElements.map(initRangeSlider).filter(isNotEmpty);\n\n  window.fsAttributes[ATTRIBUTE].resolve?.(handleInstances);\n\n  return handleInstances;\n};\n\n/**\n * Inits a range slider.\n * @param wrapperElement The wrapper element.\n * @returns The {@link HandleInstances}.\n */\nconst initRangeSlider = (wrapperElement: HTMLElement) => {\n  const settings = getSettings(wrapperElement);\n  if (!settings) return;\n\n  const handles = createHandleInstances(settings);\n  if (!handles) return;\n\n  createFillInstance(settings, handles);\n\n  const { maxRange, minRange, step, precision, totalRange, trackElement, updateOnRelease } = settings;\n\n  let { trackWidth, trackLeft, trackRight } = settings;\n  let focusedHandle: Handle | undefined;\n  let focusedHandleHasUpdated = false;\n\n  /**\n   * Calculates the value based on where the user clicked and adjusts it to the step increment,\n   * @param clientX The event `clientX` value.\n   */\n  const calculateNewValue = (clientX: number) => {\n    const value = minRange + ((clientX - trackLeft) * totalRange) / trackWidth;\n\n    const adjustedValue = adjustValueToStep(value, step, precision);\n\n    return adjustedValue;\n  };\n\n  /**\n   * Handles when the user moves the cursor/finger while holding down a {@link Handle}.\n   * @param e A `mousemove` or `touchmove` event.\n   */\n  const handleMouseMove = (e: MouseEvent | TouchEvent) => {\n    if (!focusedHandle) return;\n\n    if (e instanceof MouseEvent) e.preventDefault();\n\n    const clientX = getClientX(e);\n    const [minValue, maxValue] = focusedHandle.getConstraints();\n\n    let value: number;\n\n    if (trackLeft > clientX) value = minValue;\n    else if (trackRight < clientX) value = maxValue;\n    else value = calculateNewValue(clientX);\n\n    const hasUpdatedValue = focusedHandle.setValue(value, !updateOnRelease);\n\n    focusedHandleHasUpdated ||= hasUpdatedValue;\n  };\n\n  /**\n   * Handles when the user releases the currently focused {@link Handle}.\n   * @param e A `mouseup` or `touchend` event.\n   */\n  const handleMouseUp = (e: MouseEvent | TouchEvent) => {\n    if (e.cancelable) e.preventDefault();\n\n    document.removeEventListener('mousemove', handleMouseMove);\n    document.removeEventListener('touchmove', handleMouseMove);\n    document.removeEventListener('mouseup', handleMouseUp);\n    document.removeEventListener('touchend', handleMouseUp);\n\n    if (updateOnRelease && focusedHandleHasUpdated) focusedHandle?.updateInputElement();\n\n    focusedHandleHasUpdated = false;\n\n    focusedHandle?.element.blur();\n    focusedHandle = undefined;\n  };\n\n  /**\n   * Handles when the user holds down a {@link Handle}.\n   * @param e A `mousedown` or `touchstart` event.\n   */\n  const handleMouseDown = (e: MouseEvent | TouchEvent) => {\n    if (e.cancelable) e.preventDefault();\n\n    const clientX = getClientX(e);\n\n    document.addEventListener('mousemove', handleMouseMove);\n    document.addEventListener('touchmove', handleMouseMove, { passive: true });\n    document.addEventListener('mouseup', handleMouseUp);\n    document.addEventListener('touchend', handleMouseUp);\n\n    let value: number;\n\n    if (trackLeft > clientX) value = minRange;\n    else if (trackRight < clientX) value = maxRange;\n    else value = calculateNewValue(clientX);\n\n    const closestHandle = getClosestValidHandle(value, handles);\n    if (!closestHandle) return;\n\n    closestHandle.element.focus();\n\n    focusedHandle = closestHandle;\n\n    const hasUpdatedValue = closestHandle.setValue(value, !updateOnRelease);\n\n    focusedHandleHasUpdated ||= hasUpdatedValue;\n  };\n\n  /**\n   * Updates the stored `trackWidth` value and the Handles' position.\n   */\n  const handleDOMMutation = () => {\n    trackWidth = trackElement.clientWidth;\n\n    ({ left: trackLeft, right: trackRight } = trackElement.getBoundingClientRect());\n\n    for (const handle of handles) if (handle) handle.updateTrackWidth(trackWidth);\n  };\n\n  /**\n   * If the wrapper is initially hidden, observes mutations and performs the needed actions.\n   */\n  const observeWrapperVisibility = () => {\n    const hiddenParent = getHiddenParent(wrapperElement);\n    if (!hiddenParent) return;\n\n    const observer = new MutationObserver(() => {\n      if (isVisible(hiddenParent)) handleDOMMutation();\n    });\n\n    observer.observe(hiddenParent, {\n      attributes: true,\n      attributeFilter: ['style', 'class'],\n    });\n  };\n\n  /**\n   * Init events\n   */\n  trackElement.addEventListener('mousedown', handleMouseDown);\n  trackElement.addEventListener('touchstart', handleMouseDown, { passive: true });\n\n  observeWrapperVisibility();\n  window.addEventListener('resize', debounce(handleDOMMutation, 50));\n\n  return handles;\n};\n", "/**\n * @returns The `clientX` property of an event.\n * @param e A {@link MouseEvent} or a {@link TouchEvent}\n */\nexport const getClientX = (e: MouseEvent | TouchEvent) => {\n  if (e instanceof MouseEvent) return e.clientX;\n\n  return e.touches[0].clientX;\n};\n", "export const SPACE_KEY = ' ';\nexport const ENTER_KEY = 'Enter';\nexport const TAB_KEY = 'Tab';\nexport const ARROW_UP_KEY = 'ArrowUp';\nexport const ARROW_DOWN_KEY = 'ArrowDown';\nexport const ARROW_RIGHT_KEY = 'ArrowRight';\nexport const ARROW_LEFT_KEY = 'ArrowLeft';\n", "import { ARROW_DOWN_KEY, ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY } from '$global/constants/keyboard';\nimport { generateSelectors } from '$global/factory/selectors';\n\nexport const ATTRIBUTE = 'rangeslider';\n\nconst ATTRIBUTES_PREFIX = `fs-${ATTRIBUTE}` as const;\n\nexport const WRAPPER_ELEMENT_KEY = 'wrapper';\nexport const TRACK_ELEMENT_KEY = 'track';\nexport const FILL_ELEMENT_KEY = 'fill';\nexport const HANDLE_ELEMENT_KEY = 'handle';\nexport const DISPLAY_VALUE_ELEMENT_KEY = 'display-value';\n\nexport const MIN_SETTING_KEY = 'min';\nexport const MAX_SETTING_KEY = 'max';\nexport const START_SETTING_KEY = 'start';\nexport const STEP_SETTING_KEY = 'step';\nexport const FORMAT_DISPLAY_SETTING_KEY = 'formatdisplay';\nexport const FORMAT_DISPLAY_SETTING_VALUES = { true: 'true' } as const;\nexport const UPDATE_ACTION_SETTING_KEY = 'update';\nexport const UPDATE_ACTION_SETTING_VALUES = {\n  move: 'move',\n  release: 'release',\n} as const;\n\nexport const ATTRIBUTES = {\n  element: {\n    key: `${ATTRIBUTES_PREFIX}-element`,\n    values: {\n      /**\n       * Defines a range slider instance element.\n       */\n      wrapper: WRAPPER_ELEMENT_KEY,\n\n      /**\n       * Defines the track of the slider.\n       */\n      track: TRACK_ELEMENT_KEY,\n\n      /**\n       * Defines the fill of the slider.\n       */\n      fill: FILL_ELEMENT_KEY,\n\n      /**\n       * Defines a handle of the slider.\n       */\n      handle: HANDLE_ELEMENT_KEY,\n\n      /**\n       * Defines an element to display a Handle's value.\n       */\n      displayValue: DISPLAY_VALUE_ELEMENT_KEY,\n    },\n  },\n\n  /**\n   * Defines the minimum value of the range.\n   */\n  min: { key: `${ATTRIBUTES_PREFIX}-${MIN_SETTING_KEY}` },\n\n  /**\n   * Defines the maximum value of the range.\n   */\n  max: { key: `${ATTRIBUTES_PREFIX}-${MAX_SETTING_KEY}` },\n\n  /**\n   * Defines the start value of a handle.\n   * Must be applied to a handle element {@link ATTRIBUTES.element.values.handle}.\n   */\n  start: { key: `${ATTRIBUTES_PREFIX}-${START_SETTING_KEY}` },\n\n  /**\n   * Defines the step of the values.\n   */\n  step: { key: `${ATTRIBUTES_PREFIX}-${STEP_SETTING_KEY}` },\n\n  /**\n   * Defines if the Handles' value display should be formatted.\n   */\n  formatDisplay: { key: `${ATTRIBUTES_PREFIX}-${FORMAT_DISPLAY_SETTING_KEY}`, values: FORMAT_DISPLAY_SETTING_VALUES },\n\n  /**\n   * Defines when should the <input> elements be updated.\n   * Defaults to {@link UPDATE_ACTION_SETTING_VALUES.move}\n   */\n  updateAction: { key: `${ATTRIBUTES_PREFIX}-${UPDATE_ACTION_SETTING_KEY}`, values: UPDATE_ACTION_SETTING_VALUES },\n} as const;\n\nexport const [getSelector, queryElement] = generateSelectors(ATTRIBUTES);\n\nexport const HANDLE_INCREMENT_KEYS = [ARROW_UP_KEY, ARROW_RIGHT_KEY];\nexport const HANDLE_DECREMENT_KEYS = [ARROW_DOWN_KEY, ARROW_LEFT_KEY];\nexport const HANDLE_KEYS = [...HANDLE_INCREMENT_KEYS, ...HANDLE_DECREMENT_KEYS];\n", "import { isNotEmpty } from '@finsweet/ts-utils';\n\nimport type { HandleInstances } from '../utils/types';\n\n/**\n * Calculates the amount of decimals that a float number has.\n * @param value A number.\n */\nexport const getDecimalPrecision = (value: number) => {\n  if (!isFinite(value)) return 0;\n\n  let exponential = 1;\n  let precision = 0;\n\n  while (Math.round(value * exponential) / exponential !== value) {\n    exponential *= 10;\n    precision += 1;\n  }\n  return precision;\n};\n\n/**\n * Ensures a decimal precision on a number.\n * @param value The number to handle.\n * @param precision The amount of decimals.\n */\nconst setDecimalPrecision = (value: number, precision: number) => {\n  const pow = Math.pow(10, precision);\n\n  return Math.round(value * pow) / pow;\n};\n\n/**\n * Adjusts a numeric value to a step factor.\n * @param value The numeric value to adjust.\n * @param step The increment step.\n * @returns The adjusted value.\n */\nexport const adjustValueToStep = (value: number, step: number, precision: number) => {\n  const remainder = value % step;\n  const floor = value - remainder;\n\n  if (remainder > step / 2) return setDecimalPrecision(floor + step, precision);\n\n  return setDecimalPrecision(floor, precision);\n};\n\n/**\n * Returns the closest handle to an adjusted value.\n * @param adjustedValue The adjusted value through {@link adjustValueToStep}.\n * @param handles The {@link HandleInstances}.\n * @returns The closest valid `Handle`, if existing.\n */\nexport const getClosestValidHandle = (adjustedValue: number, [handle1, handle2]: HandleInstances) => {\n  const handle1Value = handle1.getValue();\n  const handle2Value = handle2?.getValue();\n\n  const closestValue = getClosestValue(adjustedValue, [handle1Value, handle2Value]);\n  if (typeof closestValue !== 'number') return;\n\n  const [handle1MinValue, handle1MaxValue] = handle1.getConstraints();\n\n  if (closestValue === handle1Value && adjustedValue >= handle1MinValue && adjustedValue <= handle1MaxValue) {\n    return handle1;\n  }\n\n  if (!handle2 || closestValue !== handle2Value) return;\n\n  const [handle2MinValue, handle2MaxValue] = handle2.getConstraints();\n\n  if (adjustedValue >= handle2MinValue && adjustedValue <= handle2MaxValue) return handle2;\n};\n\n/**\n * @returns The closest value from an array based on a reference value.\n * @param reference The reference value.\n * @param values The array of values to compare.\n */\nconst getClosestValue = (reference: number, values: (number | undefined)[]) => {\n  const filteredValues = values.filter(isNotEmpty);\n\n  if (!filteredValues.length) return;\n\n  const closestValue = filteredValues.reduce((previous, current) =>\n    Math.abs(current - reference) < Math.abs(previous - reference) ? current : previous\n  );\n\n  return closestValue;\n};\n", "import { Debug, isFormField } from '@finsweet/ts-utils';\n\nimport { ATTRIBUTES, getSelector, queryElement } from '../utils/constants';\nimport { getDecimalPrecision } from './values';\n\n/**\n * Constants\n */\nconst {\n  min: { key: minKey },\n  max: { key: maxKey },\n  step: { key: stepKey },\n  formatDisplay: { key: formatDisplayKey, values: formatDisplayValues },\n  updateAction: { key: updateActionKey, values: updateActionValues },\n} = ATTRIBUTES;\n\n/**\n * Collects the required settings.\n * @param wrapperElement The wrapper element.\n * @returns The settings, if no errors were found.\n */\nexport const getSettings = (\n  wrapperElement: HTMLElement\n):\n  | {\n      trackElement: HTMLElement;\n      fillElement: HTMLElement | null;\n      handleElements: HTMLElement[];\n      inputElements: HTMLInputElement[];\n      displayValueElements: HTMLElement[];\n      formatValueDisplay: boolean;\n      trackLeft: number;\n      trackRight: number;\n      trackWidth: number;\n      minRange: number;\n      maxRange: number;\n      totalRange: number;\n      step: number;\n      precision: number;\n      updateOnRelease: boolean;\n    }\n  | undefined => {\n  const trackElement = queryElement<HTMLElement>('track', { operator: 'prefixed', scope: wrapperElement });\n\n  const fillElement = queryElement<HTMLElement>('fill', { operator: 'prefixed', scope: wrapperElement });\n\n  const inputElements = [...wrapperElement.querySelectorAll('input')].filter(isFormField);\n\n  const handleElements = [\n    ...wrapperElement.querySelectorAll<HTMLElement>(getSelector('element', 'handle', { operator: 'prefixed' })),\n  ];\n\n  const displayValueElements = [\n    ...wrapperElement.querySelectorAll<HTMLElement>(getSelector('element', 'displayValue', { operator: 'prefixed' })),\n  ];\n\n  const formatValueDisplay = wrapperElement.getAttribute(formatDisplayKey) === formatDisplayValues.true;\n\n  const updateOnRelease = wrapperElement.getAttribute(updateActionKey) === updateActionValues.release;\n\n  if (!handleElements.length || !trackElement) {\n    Debug.alert('The rangeslider is missing a Track element or a Handle element.', 'error');\n    return;\n  }\n\n  const { left: trackLeft, right: trackRight } = trackElement.getBoundingClientRect();\n  const trackWidth = trackElement.clientWidth;\n  trackElement.style.position = 'relative';\n\n  const minRange = parseFloat(wrapperElement.getAttribute(minKey) || '0');\n  const maxRange = parseFloat(wrapperElement.getAttribute(maxKey) || `${minRange + 1}`);\n  const totalRange = maxRange - minRange;\n\n  if (Number.isNaN(totalRange)) {\n    Debug.alert('Please make sure min and max are numbers.', 'error');\n    return;\n  }\n\n  if (Math.sign(totalRange) === -1) {\n    Debug.alert(\"The min can't be greater than the max.\", 'error');\n    return;\n  }\n\n  const step = parseFloat(wrapperElement.getAttribute(stepKey) || `${totalRange / 100}`);\n  const precision = getDecimalPrecision(step);\n\n  if (totalRange % step > 0)\n    Debug.alert(\n      `The provided step [${step}] doesn't fit the range [${minRange},${maxRange}], are you sure you want to use this value?`,\n      'info'\n    );\n\n  return {\n    trackElement,\n    fillElement,\n    handleElements,\n    inputElements,\n    displayValueElements,\n    formatValueDisplay,\n    trackLeft,\n    trackRight,\n    trackWidth,\n    minRange,\n    maxRange,\n    totalRange,\n    step,\n    precision,\n    updateOnRelease,\n  };\n};\n", "import type { Handle } from './Handle';\n\nexport class Fill {\n  private readonly minRange;\n  private readonly totalRange;\n\n  private readonly handles: readonly [Handle, Handle | undefined];\n\n  private trackWidth: number;\n\n  constructor(\n    public readonly element: HTMLElement,\n    {\n      minRange,\n      maxRange,\n      handles,\n      trackWidth,\n    }: { minRange: number; maxRange: number; handles: readonly [Handle, Handle | undefined]; trackWidth: number }\n  ) {\n    element.style.position = 'absolute';\n    element.style.right = 'unset';\n\n    this.minRange = minRange;\n    this.totalRange = maxRange - minRange;\n\n    this.handles = handles;\n\n    this.trackWidth = trackWidth;\n\n    this.update();\n  }\n\n  /**\n   * Updates the stored track width.\n   * The `update` method is fired from the Handles.\n   * @param newTrackWidth The new track width.\n   */\n  public updateTrackWidth(newTrackWidth: number) {\n    this.trackWidth = newTrackWidth;\n  }\n\n  /**\n   * Updates the Fill width and position based on the handle's values.\n   */\n  public update(): void {\n    const {\n      element,\n      trackWidth,\n      minRange,\n      totalRange,\n      handles: [handle1, handle2],\n    } = this;\n\n    let left: number;\n    let width: number;\n\n    const leftOffset = ((handle1.getValue() - minRange) * trackWidth) / totalRange;\n\n    if (handle2) {\n      left = leftOffset;\n      width = ((handle2.getValue() - handle1.getValue()) * trackWidth) / totalRange;\n    } else {\n      left = 0;\n      width = leftOffset;\n    }\n\n    element.style.left = `${left}px`;\n    element.style.width = `${width}px`;\n  }\n}\n", "export const ARIA_ROLE_KEY = 'role';\r\nexport const ARIA_ROLE_VALUES = {\r\n  slider: 'slider',\r\n  listbox: 'listbox',\r\n  option: 'option',\r\n  columnheader: 'columnheader',\r\n  link: 'link',\r\n} as const;\r\nexport const TABINDEX_KEY = 'tabindex';\r\nexport const ARIA_LABEL_KEY = 'aria-label';\r\nexport const ARIA_LABELLEDBY_KEY = 'aria-labelledby';\r\nexport const ARIA_VALUENOW_KEY = 'aria-valuenow';\r\nexport const ARIA_VALUEMIN_KEY = 'aria-valuemin';\r\nexport const ARIA_VALUEMAX_KEY = 'aria-valuemax';\r\nexport const ARIA_SELECTED_KEY = 'aria-selected';\r\nexport const ARIA_HASPOPUP_KEY = 'aria-haspopup';\r\nexport const ARIA_MULTISELECTABLE_KEY = 'aria-multiselectable';\r\nexport const ARIA_EXPANDED_KEY = 'aria-expanded';\r\nexport const ARIA_CURRENT_KEY = 'aria-current';\r\nexport const ARIA_ACTIVEDESCENDANT_KEY = 'aria-activedescendant';\r\nexport const ARIA_PRESSED_KEY = 'aria-pressed';\r\nexport const ARIA_SORT_KEY = 'aria-sort';\r\nexport const ARIA_SORT_VALUES = {\r\n  ascending: 'ascending',\r\n  descending: 'descending',\r\n} as const;\r\n", "import {\n  ARIA_LABELLEDBY_KEY,\n  ARIA_LABEL_KEY,\n  ARIA_ROLE_KEY,\n  ARIA_ROLE_VALUES,\n  TABINDEX_KEY,\n} from '$global/constants/a11ty';\n\n/**\n * Sets the required `a11ty` attributes to a `Handle` element.\n * @param element The `Handle` element.\n * @param inputElement The correspondent `<input>` for the `Handle`, if existing.\n */\nexport const setHandleA11ty = (element: HTMLElement, inputElement?: HTMLInputElement) => {\n  element.setAttribute(ARIA_ROLE_KEY, ARIA_ROLE_VALUES.slider);\n  element.setAttribute(TABINDEX_KEY, '0');\n\n  if (![ARIA_LABEL_KEY, ARIA_LABELLEDBY_KEY].some((key) => element.getAttribute(key)) && inputElement) {\n    element.setAttribute(ARIA_LABEL_KEY, inputElement.name);\n  }\n};\n", "/**\n * Sets the required CSS styles to a `Handle` element.\n * @param element The `Handle` element.\n */\nexport const setHandleStyles = (element: HTMLElement) => {\n  element.style.position = 'absolute';\n  element.style.right = 'unset';\n  element.style.top = `50%`;\n  element.style.transform = 'translate(-50%, -50%)';\n};\n", "import { setFormFieldValue } from '@finsweet/ts-utils';\n\nimport { ARIA_VALUEMAX_KEY, ARIA_VALUEMIN_KEY, ARIA_VALUENOW_KEY } from '$global/constants/a11ty';\n\nimport { setHandleA11ty } from '../actions/a11ty';\nimport { setHandleStyles } from '../actions/styles';\nimport { adjustValueToStep } from '../actions/values';\nimport { HANDLE_INCREMENT_KEYS, HANDLE_KEYS } from '../utils/constants';\nimport type { Fill } from './Fill';\n\nexport class Handle {\n  private readonly index;\n  private readonly minRange;\n  private readonly maxRange;\n  private readonly totalRange;\n  private readonly step;\n  private readonly precision;\n\n  private readonly inputElement;\n  private readonly displayValueElement;\n  private readonly formatValueDisplay;\n\n  private fill?: Fill;\n  private sibling?: Handle;\n\n  private trackWidth;\n\n  private currentValue!: number;\n  private minValue;\n  private maxValue;\n\n  private updatingInput = false;\n\n  constructor(\n    public readonly element: HTMLElement,\n    {\n      index,\n      minRange,\n      maxRange,\n      trackWidth,\n      step,\n      precision,\n      startValue,\n      inputElement,\n      displayValueElement,\n      formatValueDisplay,\n    }: {\n      index: number;\n      minRange: number;\n      maxRange: number;\n      trackWidth: number;\n      step: number;\n      precision: number;\n      startValue: number;\n      inputElement?: HTMLInputElement;\n      displayValueElement?: HTMLElement;\n      formatValueDisplay: boolean;\n    }\n  ) {\n    this.inputElement = inputElement;\n    this.displayValueElement = displayValueElement;\n    this.formatValueDisplay = formatValueDisplay;\n\n    this.index = index;\n    this.minRange = minRange;\n    this.maxRange = maxRange;\n    this.totalRange = maxRange - minRange;\n    this.step = step;\n    this.precision = precision;\n\n    this.minValue = minRange;\n    this.maxValue = maxRange;\n\n    this.trackWidth = trackWidth;\n\n    setHandleStyles(element);\n    setHandleA11ty(element, inputElement);\n\n    this.setValue(startValue);\n    this.listenEvents();\n  }\n\n  /**\n   * Listens for internal events.\n   */\n  private listenEvents() {\n    const { element, inputElement } = this;\n\n    element.addEventListener('keydown', (e) => this.handleKeyDown(e));\n    inputElement?.addEventListener('change', () => this.handleInputChange());\n  }\n\n  /**\n   * Handles when the keyboard is used when focusing the Handle.\n   * @param e A `keydown` event.\n   */\n  private handleKeyDown(e: KeyboardEvent) {\n    const { step, currentValue } = this;\n    const { key } = e;\n\n    if (!HANDLE_KEYS.includes(key)) return;\n\n    e.preventDefault();\n\n    if (HANDLE_INCREMENT_KEYS.includes(key)) this.setValue(currentValue + step);\n    else this.setValue(currentValue - step);\n  }\n\n  /**\n   * Handles when the value of the `<input>` element is updated by third party actions.\n   */\n  private handleInputChange() {\n    const { inputElement, index, minRange, maxRange, step, precision, updatingInput } = this;\n    if (!inputElement || updatingInput) return;\n\n    const { value } = inputElement;\n\n    const numericValue = parseFloat(value);\n\n    if (numericValue) {\n      this.setValue(adjustValueToStep(numericValue, step, precision));\n\n      return;\n    }\n\n    this.setValue(index === 0 ? minRange : maxRange, false);\n  }\n\n  /**\n   * Updates the Handle's position on the track.\n   */\n  private updatePosition() {\n    const { currentValue, element, trackWidth, minRange, totalRange, fill } = this;\n\n    const left = ((currentValue - minRange) * trackWidth) / totalRange;\n\n    element.style.left = `${left}px`;\n\n    fill?.update();\n  }\n\n  /**\n   * @returns The current value of the Handle.\n   */\n  public getValue = (): number => this.currentValue;\n\n  /**\n   * Sets a new value to the Handle.\n   * The Handle's position is automatically updated based on the new value.\n   * @param newValue The new value to set.\n   * @param updateInputElement Defines if the `<input>` element should be updated. Defaults to `true`.\n   *\n   * @returns `true` if the current value was updated.\n   */\n  public setValue(newValue: number, updateInputElement = true): boolean {\n    const { currentValue, element, minValue, maxValue, displayValueElement, formatValueDisplay } = this;\n\n    if (currentValue === newValue || newValue < minValue || newValue > maxValue) return false;\n\n    this.currentValue = newValue;\n\n    this.updatePosition();\n    this.updateSiblingConstraints();\n\n    const stringValue = `${newValue}`;\n    const localeStringValue = newValue.toLocaleString();\n\n    element.setAttribute(ARIA_VALUENOW_KEY, stringValue);\n\n    if (displayValueElement) displayValueElement.textContent = formatValueDisplay ? localeStringValue : stringValue;\n\n    if (updateInputElement) this.updateInputElement();\n\n    return true;\n  }\n\n  /**\n   * Updates the input element's value.\n   */\n  public updateInputElement() {\n    this.updatingInput = true;\n\n    const { currentValue, inputElement } = this;\n\n    if (!inputElement) return;\n\n    setFormFieldValue(inputElement, `${currentValue}`);\n\n    this.updatingInput = false;\n  }\n\n  /**\n   * @returns The Handle's constraints.\n   */\n  public getConstraints = (): [number, number] => [this.minValue, this.maxValue];\n\n  /**\n   * Sets new constraints to the Handle.\n   * @param minValue The new minimum value.\n   * @param maxValue The new maximum value.\n   */\n  public setConstraints(minValue: number, maxValue: number): void {\n    const { element } = this;\n\n    element.setAttribute(ARIA_VALUEMIN_KEY, `${minValue}`);\n    element.setAttribute(ARIA_VALUEMAX_KEY, `${maxValue}`);\n\n    this.minValue = minValue;\n    this.maxValue = maxValue;\n  }\n\n  /**\n   * Updates the sibling's constaints, if existing.\n   */\n  public updateSiblingConstraints() {\n    const { index, sibling, step, minRange, maxRange, currentValue } = this;\n\n    if (!sibling) return;\n\n    if (index === 0) sibling.setConstraints(currentValue + step, maxRange);\n    else sibling.setConstraints(minRange, currentValue - step);\n  }\n\n  /**\n   * Updates the stored track width and the Handle's position on the track.\n   * @param newTrackWidth The new track width.\n   */\n  public updateTrackWidth(newTrackWidth: number) {\n    this.trackWidth = newTrackWidth;\n\n    this.fill?.updateTrackWidth(newTrackWidth);\n    this.updatePosition();\n  }\n\n  /**\n   * Adds a `Fill` instance to the Handle.\n   * @param fill A {@link Fill} instance.\n   */\n  public addFill(fill: Fill) {\n    this.fill = fill;\n  }\n\n  /**\n   * Adds a sibling Handle.\n   * @param sibling A {@link Handle} instance.\n   */\n  public addSibling(sibling: Handle) {\n    this.sibling = sibling;\n\n    this.updateSiblingConstraints();\n  }\n}\n", "import { Debug, isNotEmpty } from '@finsweet/ts-utils';\n\nimport { adjustValueToStep } from './actions/values';\nimport { Fill } from './components/Fill';\nimport { Handle } from './components/Handle';\nimport { ATTRIBUTES } from './utils/constants';\nimport type { HandleInstances, RangeSliderSettings } from './utils/types';\n\n/**\n * Creates {@link Handle} instances and sets them up.\n * @param settings The {@link RangeSliderSettings}.\n * @returns The new {@link Handle} instances.\n */\nexport const createHandleInstances = ({\n  handleElements,\n  inputElements,\n  displayValueElements,\n  formatValueDisplay,\n  minRange,\n  maxRange,\n  trackWidth,\n  step,\n  precision,\n}: RangeSliderSettings): HandleInstances | undefined => {\n  const handles = handleElements\n    .slice(0, 2)\n    .map((handleElement, index) => {\n      const rawStartValue = parseFloat(\n        handleElement.getAttribute(ATTRIBUTES.start.key) || `${index === 0 ? minRange : maxRange}`\n      );\n\n      let startValue = adjustValueToStep(rawStartValue, step, precision);\n\n      const inputElement = inputElements[index];\n      const displayValueElement = displayValueElements[index];\n\n      if (startValue < minRange) {\n        Debug.alert(\n          `The Handle start value [${startValue}] doesn't match the range, so it has been set to the min value [${minRange}].`,\n          'info'\n        );\n        startValue = minRange;\n      }\n\n      if (startValue > maxRange) {\n        Debug.alert(\n          `The Handle start value [${startValue}] doesn't match the range, so it has been set to the max value [${maxRange}].`,\n          'info'\n        );\n        startValue = maxRange;\n      }\n\n      const handle = new Handle(handleElement, {\n        index,\n        minRange,\n        maxRange,\n        trackWidth,\n        step,\n        precision,\n        startValue,\n        inputElement,\n        displayValueElement,\n        formatValueDisplay,\n      });\n\n      return handle;\n    })\n    .filter(isNotEmpty);\n\n  if (!handles.length) return;\n\n  // Sort them by start value\n  if (handles.length > 1) handles.sort((handle1, handle2) => handle1.getValue() - handle2.getValue());\n\n  const [handle1, handle2] = handles;\n\n  // Add relationships\n  if (handle2) {\n    handle1.addSibling(handle2);\n    handle2.addSibling(handle1);\n  } else handle1.setConstraints(minRange, maxRange);\n\n  return [handle1, handle2];\n};\n\n/**\n * Creates a `Fill` instance and adds it to the Handles.\n * @param settings The settings returned by {@link getSettings}.\n * @param handles The {@link HandleInstances} tuple.\n * @returns\n */\nexport const createFillInstance = (\n  { fillElement, minRange, maxRange, trackWidth }: RangeSliderSettings,\n  handles: HandleInstances\n) => {\n  if (!fillElement) return;\n\n  const fill = new Fill(fillElement, { minRange, maxRange, trackWidth, handles });\n  const [handle1, handle2] = handles;\n\n  handle1.addFill(fill);\n  handle2?.addFill(fill);\n};\n", "import { assessScript } from '$global/factory/assess';\nimport { initAttributes } from '$global/factory/init';\n\nimport { version } from '../package.json';\nimport { init } from './init';\nimport { ATTRIBUTE } from './utils/constants';\n\n/**\n * Init\n */\ninitAttributes();\n\nwindow.fsAttributes[ATTRIBUTE] ||= {};\n\nconst { preventsLoad } = assessScript();\nconst attribute = window.fsAttributes[ATTRIBUTE];\n\nattribute.version = version;\n\nif (preventsLoad) attribute.init = init;\nelse {\n  window.Webflow ||= [];\n  window.Webflow.push(init);\n}\n"],
  "mappings": "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",
  "names": []
}
